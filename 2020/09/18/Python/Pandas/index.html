<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luyilin.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="123import pandas as pdimport numpy as nppd.__version__     &amp;apos;0.23.4&amp;apos;Pandas 基本数据结构Series 对象Pandas 的 Series 对象是一个带索引数据构成的一维数组。可以用一个数组创建 Series 对象 12data &#x3D; pd.Series([0.25, 0.5, 0.75, 1.0])data">
<meta property="og:type" content="article">
<meta property="og:title" content="Python&#x2F;Pandas">
<meta property="og:url" content="http://luyilin.top/2020/09/18/Python/Pandas/index.html">
<meta property="og:site_name" content="引而不发，跃如也">
<meta property="og:description" content="123import pandas as pdimport numpy as nppd.__version__     &amp;apos;0.23.4&amp;apos;Pandas 基本数据结构Series 对象Pandas 的 Series 对象是一个带索引数据构成的一维数组。可以用一个数组创建 Series 对象 12data &#x3D; pd.Series([0.25, 0.5, 0.75, 1.0])data">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-09-18T09:21:55.088Z">
<meta property="article:modified_time" content="2020-09-18T09:22:32.937Z">
<meta property="article:author" content="luyilin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://luyilin.top/2020/09/18/Python/Pandas/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Python/Pandas | 引而不发，跃如也</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">引而不发，跃如也</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://luyilin.top/2020/09/18/Python/Pandas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="luyilin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="引而不发，跃如也">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Python/Pandas
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-18 17:21:55 / Modified: 17:22:32" itemprop="dateCreated datePublished" datetime="2020-09-18T17:21:55+08:00">2020-09-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">pd.__version__</span><br></pre></td></tr></table></figure>




<pre><code>&apos;0.23.4&apos;</code></pre><h1 id="Pandas-基本数据结构"><a href="#Pandas-基本数据结构" class="headerlink" title="Pandas 基本数据结构"></a>Pandas 基本数据结构</h1><h2 id="Series-对象"><a href="#Series-对象" class="headerlink" title="Series 对象"></a>Series 对象</h2><p>Pandas 的 Series 对象是一个带索引数据构成的一维数组。可以用一个数组创建 Series 对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.Series([<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1.0</span>])</span><br><span class="line">data</span><br></pre></td></tr></table></figure>




<pre><code>0    0.25
1    0.50
2    0.75
3    1.00
dtype: float64</code></pre><p>Series 对象将一组数据和一组索引绑定在一起，我们可以通过 values 属性和 index 属性获取数据。values 属性返回的结果与 NumPy 数组类似</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.values</span><br></pre></td></tr></table></figure>




<pre><code>array([0.25, 0.5 , 0.75, 1.  ])</code></pre><p>index 属性返回的结果是一个类型为 pd.Index 的类数组对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.index</span><br></pre></td></tr></table></figure>




<pre><code>RangeIndex(start=0, stop=4, step=1)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line">data[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>




<pre><code>1    0.50
2    0.75
dtype: float64</code></pre><h3 id="Serise是通用的NumPy数组"><a href="#Serise是通用的NumPy数组" class="headerlink" title="Serise是通用的NumPy数组"></a>Serise是通用的NumPy数组</h3><p>NumPy 数组通过隐式定义的整数索引获取数值，而 Pandas 的 Series 对象用一种显式定义的索引与数值关联，因此，Serise的索引不仅仅可以是整数，还可以是其他任意类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = pd.Series([<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1.0</span>],</span><br><span class="line">                        index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line">data[<span class="string">'b'</span>]</span><br></pre></td></tr></table></figure>




<pre><code>0.5</code></pre><h3 id="Series是特殊的字典"><a href="#Series是特殊的字典" class="headerlink" title="Series是特殊的字典"></a>Series是特殊的字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">population_dict = &#123;<span class="string">'California'</span>: <span class="number">38332521</span>,</span><br><span class="line">                           <span class="string">'Texas'</span>: <span class="number">26448193</span>,</span><br><span class="line">                           <span class="string">'New York'</span>: <span class="number">19651127</span>,</span><br><span class="line">                           <span class="string">'Florida'</span>: <span class="number">19552860</span>,</span><br><span class="line">                           <span class="string">'Illinois'</span>: <span class="number">12882135</span>&#125;</span><br><span class="line">population = pd.Series(population_dict)</span><br><span class="line">population</span><br></pre></td></tr></table></figure>




<pre><code>California    38332521
Texas         26448193
New York      19651127
Florida       19552860
Illinois      12882135
dtype: int64</code></pre><p>和字典不同，Series 对象还支持数组形式的操作，比如切片</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">population[<span class="string">'California'</span>:<span class="string">'New York'</span>]</span><br></pre></td></tr></table></figure>




<pre><code>California    38332521
Texas         26448193
New York      19651127
dtype: int64</code></pre><h3 id="创建Serise对象"><a href="#创建Serise对象" class="headerlink" title="创建Serise对象"></a>创建Serise对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用   pd.Series(data, index=index)</span></span><br><span class="line"><span class="comment"># 字典</span></span><br><span class="line">pd.Series(&#123;<span class="number">2</span>:<span class="string">'a'</span>, <span class="number">1</span>:<span class="string">'b'</span>, <span class="number">3</span>:<span class="string">'c'</span>&#125;)</span><br></pre></td></tr></table></figure>




<pre><code>2    a
1    b
3    c
dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Series(&#123;<span class="number">2</span>:<span class="string">'a'</span>, <span class="number">1</span>:<span class="string">'b'</span>, <span class="number">3</span>:<span class="string">'c'</span>&#125;, index=[<span class="number">3</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>




<pre><code>3    c
2    a
dtype: object</code></pre><h2 id="DataFrame-对象"><a href="#DataFrame-对象" class="headerlink" title="DataFrame 对象"></a>DataFrame 对象</h2><h3 id="DataFrame是通用的NumPy数组"><a href="#DataFrame是通用的NumPy数组" class="headerlink" title="DataFrame是通用的NumPy数组"></a>DataFrame是通用的NumPy数组</h3><p>DataFrame 就可以看作是一种既有灵活的行索引，又有灵活列名的二维数组。可以把 DataFrame 看成是有序排列的若干 Series 对象。这里的“排列”指的是它们拥有共同的索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Series</span></span><br><span class="line">population_dict = &#123;<span class="string">'California'</span>: <span class="number">38332521</span>,</span><br><span class="line">                           <span class="string">'Texas'</span>: <span class="number">26448193</span>,</span><br><span class="line">                           <span class="string">'New York'</span>: <span class="number">19651127</span>,</span><br><span class="line">                           <span class="string">'Florida'</span>: <span class="number">19552860</span>,</span><br><span class="line">                           <span class="string">'Illinois'</span>: <span class="number">12882135</span>&#125;</span><br><span class="line">population = pd.Series(population_dict)</span><br><span class="line"></span><br><span class="line">area_dict = &#123;<span class="string">'California'</span>: <span class="number">423967</span>, <span class="string">'Texas'</span>: <span class="number">695662</span>, <span class="string">'New York'</span>: <span class="number">141297</span>,</span><br><span class="line">             <span class="string">'Florida'</span>: <span class="number">170312</span>, <span class="string">'Illinois'</span>: <span class="number">149995</span>&#125;</span><br><span class="line">area = pd.Series(area_dict)</span><br><span class="line"></span><br><span class="line">population,area</span><br></pre></td></tr></table></figure>




<pre><code>(California    38332521
 Texas         26448193
 New York      19651127
 Florida       19552860
 Illinois      12882135
 dtype: int64,
 California    423967
 Texas         695662
 New York      141297
 Florida       170312
 Illinois      149995
 dtype: int64)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">states = pd.DataFrame(&#123;<span class="string">'Population'</span>: population,</span><br><span class="line">                               <span class="string">'Area'</span>: area&#125;)</span><br><span class="line">states</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Population</th>
      <th>Area</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>California</th>
      <td>38332521</td>
      <td>423967</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>26448193</td>
      <td>695662</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>19651127</td>
      <td>141297</td>
    </tr>
    <tr>
      <th>Florida</th>
      <td>19552860</td>
      <td>170312</td>
    </tr>
    <tr>
      <th>Illinois</th>
      <td>12882135</td>
      <td>149995</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">states.index</span><br></pre></td></tr></table></figure>




<pre><code>Index([&apos;California&apos;, &apos;Texas&apos;, &apos;New York&apos;, &apos;Florida&apos;, &apos;Illinois&apos;], dtype=&apos;object&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存放列标签 </span></span><br><span class="line">states.columns</span><br></pre></td></tr></table></figure>




<pre><code>Index([&apos;Population&apos;, &apos;Area&apos;], dtype=&apos;object&apos;)</code></pre><p>因此 DataFrame 可以看作一种通用的 NumPy 二维数组，它的行与列都可以通过索引获取。</p>
<h3 id="DataFrame是特殊的字典"><a href="#DataFrame是特殊的字典" class="headerlink" title="DataFrame是特殊的字典"></a>DataFrame是特殊的字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">states[<span class="string">'Area'</span>]</span><br></pre></td></tr></table></figure>




<pre><code>California    423967
Texas         695662
New York      141297
Florida       170312
Illinois      149995
Name: Area, dtype: int64</code></pre><h3 id="创建DataFrame对象"><a href="#创建DataFrame对象" class="headerlink" title="创建DataFrame对象"></a>创建DataFrame对象</h3><ol>
<li>通过Series对象创建</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(population, columns = [<span class="string">'Population'</span>])</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Population</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>California</th>
      <td>38332521</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>26448193</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>19651127</td>
    </tr>
    <tr>
      <th>Florida</th>
      <td>19552860</td>
    </tr>
    <tr>
      <th>Illinois</th>
      <td>12882135</td>
    </tr>
  </tbody>
</table>
</div>



<ol start="2">
<li>通过字典创建</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = [&#123;<span class="string">'a'</span>: i, <span class="string">'b'</span>: <span class="number">2</span> * i&#125;  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">pd.DataFrame(data)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缺失值NaN</span></span><br><span class="line">pd.DataFrame([&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'b'</span>: <span class="number">3</span>, <span class="string">'c'</span>: <span class="number">4</span>&#125;])</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1.0</td>
      <td>2</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>NaN</td>
      <td>3</td>
      <td>4.0</td>
    </tr>
  </tbody>
</table>
</div>



<ol start="3">
<li>通过 Series 对象字典创建。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(&#123;<span class="string">'population'</span>: population,<span class="string">'area'</span>: area&#125;)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>population</th>
      <th>area</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>California</th>
      <td>38332521</td>
      <td>423967</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>26448193</td>
      <td>695662</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>19651127</td>
      <td>141297</td>
    </tr>
    <tr>
      <th>Florida</th>
      <td>19552860</td>
      <td>170312</td>
    </tr>
    <tr>
      <th>Illinois</th>
      <td>12882135</td>
      <td>149995</td>
    </tr>
  </tbody>
</table>
</div>



<ol start="4">
<li>通过 NumPy 二维数组创建。假如有一个二维数组，就可以创建一个可以指定行列索引值的 DataFrame。如果不指定行列索引值，那么行列默认都是整数索引值</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(np.random.rand(<span class="number">3</span>, <span class="number">2</span>),columns=[<span class="string">'foo'</span>, <span class="string">'bar'</span>],</span><br><span class="line">             index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>foo</th>
      <th>bar</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0.266475</td>
      <td>0.446555</td>
    </tr>
    <tr>
      <th>b</th>
      <td>0.343573</td>
      <td>0.323659</td>
    </tr>
    <tr>
      <th>c</th>
      <td>0.369059</td>
      <td>0.243293</td>
    </tr>
  </tbody>
</table>
</div>



<ol start="5">
<li>通过 NumPy 结构化数组创建</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = np.zeros(<span class="number">3</span>, dtype=[(<span class="string">'A'</span>, <span class="string">'i8'</span>), (<span class="string">'B'</span>, <span class="string">'f8'</span>)])</span><br><span class="line">A</span><br></pre></td></tr></table></figure>




<pre><code>array([(0, 0.), (0, 0.), (0, 0.)], dtype=[(&apos;A&apos;, &apos;&lt;i8&apos;), (&apos;B&apos;, &apos;&lt;f8&apos;)])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(A)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>0.0</td>
    </tr>
  </tbody>
</table>
</div>



<h2 id="Pandas的Index对象"><a href="#Pandas的Index对象" class="headerlink" title="Pandas的Index对象"></a>Pandas的Index对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ind = pd.Index([<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>])</span><br><span class="line">ind</span><br></pre></td></tr></table></figure>




<pre><code>Int64Index([2, 3, 5, 7, 11], dtype=&apos;int64&apos;)</code></pre><h3 id="将Index看作不可变数组"><a href="#将Index看作不可变数组" class="headerlink" title="将Index看作不可变数组"></a>将Index看作不可变数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ind[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>




<pre><code>3</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ind[::<span class="number">2</span>]</span><br></pre></td></tr></table></figure>




<pre><code>Int64Index([2, 5, 11], dtype=&apos;int64&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(ind.size, ind.shape, ind.ndim, ind.dtype)</span><br></pre></td></tr></table></figure>

<pre><code>5 (5,) 1 int64</code></pre><p>Index 对象与 NumPy 数组之间的不同在于，Index 对象的索引是不可变的，也就是说不能通过通常的方式进行调整：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ind[<span class="number">1</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-27-906a9fa1424c&gt; in &lt;module&gt;
----&gt; 1 ind[1] = 0


~\Anaconda3\lib\site-packages\pandas\core\indexes\base.py in __setitem__(self, key, value)
   2063 
   2064     def __setitem__(self, key, value):
-&gt; 2065         raise TypeError(&quot;Index does not support mutable operations&quot;)
   2066 
   2067     def __getitem__(self, key):


TypeError: Index does not support mutable operations</code></pre><h3 id="将Index看作有序集合"><a href="#将Index看作有序集合" class="headerlink" title="将Index看作有序集合"></a>将Index看作有序集合</h3><p> Index 对象遵循 Python 标准库的集合（set）数据结构的许多习惯用法，包括并集、交集、差集等</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">indA = pd.Index([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line">indB = pd.Index([<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indA &amp; indB  <span class="comment"># 交集</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indA | indB  <span class="comment"># 并集</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indA ^ indB  <span class="comment"># 异或</span></span><br></pre></td></tr></table></figure>

<h1 id="数据取值与选择"><a href="#数据取值与选择" class="headerlink" title="数据取值与选择"></a>数据取值与选择</h1><h2 id="Series-数据选择方法"><a href="#Series-数据选择方法" class="headerlink" title="Series 数据选择方法"></a>Series 数据选择方法</h2><p>Series 对象与一维 NumPy 数组和标准 Python 字典在许多方面都一样</p>
<ol>
<li>将Series看做字典</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = pd.Series([<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1.0</span>],</span><br><span class="line">                 index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line">data[<span class="string">'a'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'e'</span>] = <span class="number">1.25</span></span><br><span class="line">data</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将Series看作一维数组</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将显式索引作为切片</span></span><br><span class="line">data[<span class="string">'a'</span>:<span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将隐式整数索引作为切片</span></span><br><span class="line">data[<span class="number">0</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 掩码</span></span><br><span class="line">data[(data &gt; <span class="number">0.3</span>) &amp; (data &lt; <span class="number">0.8</span>)]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 花哨的索引</span></span><br><span class="line">data[[<span class="string">'a'</span>, <span class="string">'e'</span>]]</span><br></pre></td></tr></table></figure>

<ul>
<li>注： 当使用显式索引（即 data[‘a’:’c’]）作切片时，结果包含最后一个索引；而当使用隐式索引（即 data[0:2]）作切片时，结果不包含最后一个索引。</li>
</ul>
<ol start="3">
<li>索引器：<code>loc</code>、<code>iloc</code>和<code>ix</code></li>
</ol>
<p>如果 Series 是显式整数索引，那么 data[1] 这样的取值操作会使用显式索引，而 data[1:3] 这样的切片操作却会使用隐式索引。会造成混淆。所以 Pandas 提供了一些索引器（indexer）属性来作为取值的方法。它们不是 Series 对象的函数方法，而是暴露切片接口的属性。</p>
<pre><code>1. loc属性，表示取值和切片都是显式的</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.Series([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], index=[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line">data</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.loc[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<pre><code>2. iloc,表示取值和切片都是 Python 形式的隐式索引</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.iloc[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<pre><code>3.ix, 它是前两种索引器的混合形式，在 Series 对象中 ix 等价于标准的 []（Python 列表）取值方式。ix 索引器主要用于 DataFrame 对象</code></pre><h2 id="DataFrame数据选择方法"><a href="#DataFrame数据选择方法" class="headerlink" title="DataFrame数据选择方法"></a>DataFrame数据选择方法</h2><ol>
<li>将DataFrame看作字典</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">area = pd.Series(&#123;<span class="string">'California'</span>: <span class="number">423967</span>, <span class="string">'Texas'</span>: <span class="number">695662</span>,</span><br><span class="line">                          <span class="string">'New York'</span>: <span class="number">141297</span>, <span class="string">'Florida'</span>: <span class="number">170312</span>,</span><br><span class="line">                          <span class="string">'Illinois'</span>: <span class="number">149995</span>&#125;)</span><br><span class="line">pop = pd.Series(&#123;<span class="string">'California'</span>: <span class="number">38332521</span>, <span class="string">'Texas'</span>: <span class="number">26448193</span>,</span><br><span class="line">                         <span class="string">'New York'</span>: <span class="number">19651127</span>, <span class="string">'Florida'</span>: <span class="number">19552860</span>,</span><br><span class="line">                         <span class="string">'Illinois'</span>: <span class="number">12882135</span>&#125;)</span><br><span class="line">data = pd.DataFrame(&#123;<span class="string">'area'</span>:area, <span class="string">'pop'</span>:pop&#125;)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'area'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.area</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'density'</span>] = data[<span class="string">'pop'</span>] / data[<span class="string">'area'</span>]</span><br><span class="line">data</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将DataFrame看作二维数组</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.values</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转置</span></span><br><span class="line">data.T</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.values[<span class="number">0</span>]<span class="comment">#第一行</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'area'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.iloc[:<span class="number">3</span>,:<span class="number">2</span>] <span class="comment">#三行两列</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.loc[:<span class="string">'Illinois'</span>, :<span class="string">'pop'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.ix[:<span class="number">3</span>, :<span class="string">'pop'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># loc与花哨索引组合</span></span><br><span class="line">data.loc[data.density &gt; <span class="number">100</span>, [<span class="string">'pop'</span>, <span class="string">'density'</span>]]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>其他取值方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'Florida'</span>:<span class="string">'Illinois'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[data.density &gt; <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<h1 id="Pandas数值运算方法"><a href="#Pandas数值运算方法" class="headerlink" title="Pandas数值运算方法"></a>Pandas数值运算方法</h1><p>对于一元运算（像函数与三角函数），这些通用函数将在输出结果中保留索引和列标签；而对于二元运算（如加法和乘法），Pandas 在传递通用函数时会自动对齐索引进行计算。这就意味着，保存数据内容与组合不同来源的数据——两处在 NumPy 数组中都容易出错的地方——变成了 Pandas 的杀手锏</p>
<h2 id="通用函数：保留索引"><a href="#通用函数：保留索引" class="headerlink" title="通用函数：保留索引"></a>通用函数：保留索引</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">42</span>)</span><br><span class="line">ser = pd.Series(rng.randint(<span class="number">0</span>, <span class="number">10</span>, <span class="number">4</span>))</span><br><span class="line">rng</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(rng.randint(<span class="number">0</span>, <span class="number">10</span>, (<span class="number">3</span>, <span class="number">4</span>)),</span><br><span class="line">                         columns=[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>])</span><br><span class="line">df</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.exp(ser)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.sin(df * np.pi / <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h2 id="通用函数：索引对齐"><a href="#通用函数：索引对齐" class="headerlink" title="通用函数：索引对齐"></a>通用函数：索引对齐</h2><ol>
<li>Series索引对齐</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">area = pd.Series(&#123;<span class="string">'Alaska'</span>: <span class="number">1723337</span>, <span class="string">'Texas'</span>: <span class="number">695662</span>,</span><br><span class="line">       <span class="string">'California'</span>: <span class="number">423967</span>&#125;, name=<span class="string">'area'</span>)</span><br><span class="line">population = pd.Series(&#123;<span class="string">'California'</span>: <span class="number">38332521</span>, <span class="string">'Texas'</span>: <span class="number">26448193</span>,</span><br><span class="line">       <span class="string">'New York'</span>: <span class="number">19651127</span>&#125;, name=<span class="string">'population'</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">population / area</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>DataFrame索引对齐</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = pd.DataFrame(rng.randint(<span class="number">0</span>, <span class="number">20</span>, (<span class="number">2</span>, <span class="number">2</span>)),</span><br><span class="line">                         columns=list(<span class="string">'AB'</span>))</span><br><span class="line">A</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B = pd.DataFrame(rng.randint(<span class="number">0</span>, <span class="number">10</span>, (<span class="number">3</span>, <span class="number">3</span>)),</span><br><span class="line">                         columns=list(<span class="string">'BAC'</span>))</span><br><span class="line">B</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A+B</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#我们将用 A 中所有值的均值来填充缺失值</span></span><br><span class="line"><span class="comment">#（计算 A 的均值需要用 stack 将二维数组压缩成一维数组）：</span></span><br><span class="line">fill = A.stack().mean()</span><br><span class="line">A.add(B, fill_value=fill)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Python运算符</th>
<th>Pandas方法</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>add()</td>
</tr>
<tr>
<td>-</td>
<td>sub()、subtract()</td>
</tr>
<tr>
<td>*</td>
<td>mul()、multiply()</td>
</tr>
<tr>
<td>/</td>
<td>truediv()、div()、divide()</td>
</tr>
<tr>
<td>//</td>
<td>floordiv()</td>
</tr>
<tr>
<td>%</td>
<td>mod()</td>
</tr>
<tr>
<td>**</td>
<td>pow()</td>
</tr>
</tbody></table>
<h2 id="通用函数：DataFrame与Series的运算"><a href="#通用函数：DataFrame与Series的运算" class="headerlink" title="通用函数：DataFrame与Series的运算"></a>通用函数：DataFrame与Series的运算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = rng.randint(<span class="number">10</span>, size=(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">A</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A - A[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h1 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h1><ol>
<li>None</li>
</ol>
<p>None 是一个 Python 对象，所以不能作为任何 NumPy / Pandas 数组类型的缺失值，只能用于 ‘object’ 数组类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vals1 = np.array([<span class="number">1</span>, <span class="literal">None</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">vals1</span><br></pre></td></tr></table></figure>

<ul>
<li>注：如 sum() 或者 min()，那么通常会出现类型错误</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vals1.sum()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>NaN:数值类型的缺失值</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vals2 = np.array([<span class="number">1</span>, np.nan, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">vals2.dtype</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + np.nan</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> * np.nan</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vals2.sum(), vals2.min(), vals2.max()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略缺失值</span></span><br><span class="line">np.nansum(vals2), np.nanmin(vals2), np.nanmax(vals2)</span><br></pre></td></tr></table></figure>

<h2 id="处理缺失值-1"><a href="#处理缺失值-1" class="headerlink" title="处理缺失值"></a>处理缺失值</h2><ol>
<li>发现缺失值</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.Series([<span class="number">1</span>, np.nan, <span class="string">'hello'</span>, <span class="literal">None</span>])</span><br><span class="line">data.isnull()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[data.notnull()]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>剔除缺失值</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.dropna()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DataFrame 情形</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">1</span>,      np.nan, <span class="number">2</span>],</span><br><span class="line">                           [<span class="number">2</span>,      <span class="number">3</span>,      <span class="number">5</span>],</span><br><span class="line">                           [np.nan, <span class="number">4</span>,      <span class="number">6</span>]])</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<p>我们没法从 DataFrame 中单独剔除一个值，要么是剔除缺失值所在的整行，要么是整列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.dropna()<span class="comment">#默认情况下，dropna() 会剔除任何包含缺失值的整行数据</span></span><br></pre></td></tr></table></figure>

<p>通过设置 how 或 thresh 参数来满足，它们可以设置剔除行或列缺失值的数量阈值。</p>
<p>默认设置是 how=’any’，也就是说只要有缺失值就剔除整行或整列（通过 axis 设置坐标轴）。你还可以设置 how=’all’，这样就只会剔除全部是缺失值的行或列了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="number">3</span>] = np.nan</span><br><span class="line">df</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.dropna(axis=<span class="string">'columns'</span>, how=<span class="string">'all'</span>)</span><br></pre></td></tr></table></figure>

<p>还可以通过 thresh 参数设置行或列中非缺失值的最小数量，从而实现更加个性化的配置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.dropna(axis=<span class="string">'rows'</span>, thresh=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>填充缺失值</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.Series([<span class="number">1</span>, np.nan, <span class="number">2</span>, <span class="literal">None</span>, <span class="number">3</span>], index=list(<span class="string">'abcde'</span>))</span><br><span class="line">data</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以用缺失值前面的有效值来从前往后填充（forward-fill）</span></span><br><span class="line">data.fillna(method=<span class="string">'ffill'</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从后往前填充back-fill</span></span><br><span class="line">data.fillna(method=<span class="string">'bfill'</span>)</span><br></pre></td></tr></table></figure>

<p>DataFrame 的操作方法与 Series 类似，只是在填充时需要设置坐标轴参数 axis</p>
<h1 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h1><p>将高维数组转换成类似一维 Series 和二维 DataFrame 对象的形式。</p>
<h2 id="多级索引Series"><a href="#多级索引Series" class="headerlink" title="多级索引Series"></a>多级索引Series</h2><ol>
<li>一维情形</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">index = [(<span class="string">'California'</span>, <span class="number">2000</span>), (<span class="string">'California'</span>, <span class="number">2010</span>),</span><br><span class="line">                (<span class="string">'New York'</span>, <span class="number">2000</span>), (<span class="string">'New York'</span>, <span class="number">2010</span>),</span><br><span class="line">                (<span class="string">'Texas'</span>, <span class="number">2000</span>), (<span class="string">'Texas'</span>, <span class="number">2010</span>)]</span><br><span class="line">populations = [<span class="number">33871648</span>, <span class="number">37253956</span>,</span><br><span class="line">              <span class="number">18976457</span>, <span class="number">19378102</span>,</span><br><span class="line">              <span class="number">20851820</span>, <span class="number">25145561</span>]</span><br><span class="line"></span><br><span class="line">index = pd.MultiIndex.from_tuples(index)</span><br><span class="line">index</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop = pd.Series(populations, index=index)</span><br><span class="line">pop</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop[:, <span class="number">2010</span>]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>多维情形</li>
</ol>
<figure class="highlight plain"><figcaption><span>方法可以快速将一个多级索引的``` Series ```转化为普通索引的 ```DataFrame```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">pop_df &#x3D; pop.unstack()</span><br><span class="line">pop_df</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop_df.stack()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop_df = pd.DataFrame(&#123;<span class="string">'total'</span>: pop,</span><br><span class="line">                       <span class="string">'under18'</span>: [<span class="number">9267089</span>, <span class="number">9284094</span>,</span><br><span class="line">                                   <span class="number">4687374</span>, <span class="number">4318033</span>,</span><br><span class="line">                                   <span class="number">5906301</span>, <span class="number">6879014</span>]&#125;)</span><br><span class="line">pop_df</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f_u18 = pop_df[<span class="string">'under18'</span>] / pop_df[<span class="string">'total'</span>]</span><br><span class="line">f_u18.unstack()</span><br></pre></td></tr></table></figure>

<h2 id="多级索引的创建方法"><a href="#多级索引的创建方法" class="headerlink" title="多级索引的创建方法"></a>多级索引的创建方法</h2><p>为 Series 或 DataFrame 创建多级索引最直接的办法就是将 index 参数设置为至少二维的索引数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">4</span>, <span class="number">2</span>),</span><br><span class="line">                index=[[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]],</span><br><span class="line">                columns=[<span class="string">'data1'</span>, <span class="string">'data2'</span>])</span><br><span class="line">df</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典</span></span><br><span class="line">data = &#123;(<span class="string">'California'</span>, <span class="number">2000</span>): <span class="number">33871648</span>,</span><br><span class="line">        (<span class="string">'California'</span>, <span class="number">2010</span>): <span class="number">37253956</span>,</span><br><span class="line">        (<span class="string">'Texas'</span>, <span class="number">2000</span>): <span class="number">20851820</span>,</span><br><span class="line">        (<span class="string">'Texas'</span>, <span class="number">2010</span>): <span class="number">25145561</span>,</span><br><span class="line">        (<span class="string">'New York'</span>, <span class="number">2000</span>): <span class="number">18976457</span>,</span><br><span class="line">        (<span class="string">'New York'</span>, <span class="number">2010</span>): <span class="number">19378102</span>&#125;</span><br><span class="line">pd.Series(data)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>MultiIndex</code> 方法</li>
</ul>
<ol>
<li>显式地创建多级索引</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.MultiIndex.from_arrays(</span><br><span class="line">    [[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.MultiIndex.from_tuples(</span><br><span class="line">    [(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'a'</span>, <span class="number">2</span>), (<span class="string">'b'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>)])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 笛卡尔积（Cartesian product）</span></span><br><span class="line">pd.MultiIndex.from_product(</span><br><span class="line">    [[<span class="string">'a'</span>, <span class="string">'b'</span>], [<span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.MultiIndex(levels=[[<span class="string">'a'</span>, <span class="string">'b'</span>], [<span class="number">1</span>, <span class="number">2</span>]],</span><br><span class="line">            labels=[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>多级索引的等级名称</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop.index.names = [<span class="string">'state'</span>, <span class="string">'year'</span>]</span><br><span class="line">pop</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>多级列索引</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多级行列索引</span></span><br><span class="line">index = pd.MultiIndex.from_product([[<span class="number">2013</span>, <span class="number">2014</span>], [<span class="number">1</span>, <span class="number">2</span>]],</span><br><span class="line">            names=[<span class="string">'year'</span>, <span class="string">'visit'</span>])</span><br><span class="line">columns = pd.MultiIndex.from_product([[<span class="string">'Bob'</span>, <span class="string">'Guido'</span>, <span class="string">'Sue'</span>], [<span class="string">'HR'</span>, <span class="string">'Temp'</span>]],</span><br><span class="line">            names=[<span class="string">'subject'</span>, <span class="string">'type'</span>])</span><br><span class="line"></span><br><span class="line">data = np.round(np.random.randn(<span class="number">4</span>, <span class="number">6</span>), <span class="number">1</span>)</span><br><span class="line">data[:, ::<span class="number">2</span>] *= <span class="number">10</span></span><br><span class="line">data += <span class="number">37</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建DataFrame</span></span><br><span class="line">health_data = pd.DataFrame(data, index=index, columns=columns)</span><br><span class="line">health_data</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">health_data[<span class="string">'Guido'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="多级索引的取值与切片"><a href="#多级索引的取值与切片" class="headerlink" title="多级索引的取值与切片"></a>多级索引的取值与切片</h2><ol>
<li>Series多级索引</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop[<span class="string">'California'</span>, <span class="number">2000</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop[<span class="string">'California'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop.loc[<span class="string">'California'</span>:<span class="string">'New York'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop[[<span class="string">'California'</span>, <span class="string">'Texas'</span>]]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>DataFrame多级索引</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">health_data</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">health_data[<span class="string">'Guido'</span>, <span class="string">'HR'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">health_data.iloc[:<span class="number">2</span>, :<span class="number">2</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">health_data.loc[:, (<span class="string">'Bob'</span>, <span class="string">'HR'</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="多级索引行列转换"><a href="#多级索引行列转换" class="headerlink" title="多级索引行列转换"></a>多级索引行列转换</h2><ol>
<li>排序</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index = pd.MultiIndex.from_product([[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>], [<span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line">data = pd.Series(np.random.rand(<span class="number">6</span>), index=index)</span><br><span class="line">data.index.names = [<span class="string">'char'</span>, <span class="string">'int'</span>]</span><br><span class="line">data</span><br></pre></td></tr></table></figure>

<p>此时不能切片（无序）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = data.sort_index()</span><br><span class="line">data</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'a'</span>:<span class="string">'b'</span>]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>索引stack与unstack</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop.unstack(level=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop.unstack(level=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>索引的设置与重置</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop_flat = pop.reset_index(name=<span class="string">'population'</span>)</span><br><span class="line">pop_flat</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop_flat.set_index([<span class="string">'state'</span>, <span class="string">'year'</span>])</span><br></pre></td></tr></table></figure>

<h2 id="多级索引的数据累计方法"><a href="#多级索引的数据累计方法" class="headerlink" title="多级索引的数据累计方法"></a>多级索引的数据累计方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">health_data</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data_mean = health_data.mean(level=<span class="string">'year'</span>)</span><br><span class="line">data_mean</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_mean.mean(axis=<span class="number">1</span>, level=<span class="string">'type'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="合并数据集：Concat与Append操作"><a href="#合并数据集：Concat与Append操作" class="headerlink" title="合并数据集：Concat与Append操作"></a>合并数据集：Concat与Append操作</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_df</span><span class="params">(cols, ind)</span>:</span></span><br><span class="line">   <span class="string">"""一个简单的DataFrame"""</span></span><br><span class="line">   data = &#123;c: [str(c) + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> ind]</span><br><span class="line">           <span class="keyword">for</span> c <span class="keyword">in</span> cols&#125;</span><br><span class="line">   <span class="keyword">return</span> pd.DataFrame(data, ind)</span><br><span class="line"></span><br><span class="line"><span class="comment"># DataFrame示例</span></span><br><span class="line">make_df(<span class="string">'ABC'</span>, range(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<h2 id="pd-concat方法"><a href="#pd-concat方法" class="headerlink" title="pd.concat方法"></a><code>pd.concat</code>方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pandas 0.18版中的函数签名</span></span><br><span class="line">pd.concat(objs, axis=<span class="number">0</span>, join=<span class="string">'outer'</span>, join_axes=<span class="literal">None</span>, ignore_index=<span class="literal">False</span>,keys=<span class="literal">None</span>, levels=<span class="literal">None</span>, names=<span class="literal">None</span>, verify_integrity=<span class="literal">False</span>,copy=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>简单地合并一维的 Series 或 DataFrame 对象，与 np.concatenate() 合并数组一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ser1 = pd.Series([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>], index=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">ser2 = pd.Series([<span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>], index=[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">pd.concat([ser1, ser2])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df1 = make_df(<span class="string">'AB'</span>, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">df2 = make_df(<span class="string">'AB'</span>, [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(df1); print(df2); print(pd.concat([df1, df2]))</span><br></pre></td></tr></table></figure>

<p>默认情况下，DataFrame 的合并都是逐行进行的（默认设置是 axis=0）。与 np.concatenate() 一样，pd.concat 也可以设置合并坐标轴</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df3 = make_df(<span class="string">'AB'</span>, [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">df4 = make_df(<span class="string">'CD'</span>, [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">print(df3); print(df4); print(pd.concat([df3, df4], axis=<span class="number">1</span>))<span class="comment"># axis = 'col(按列合并，按行延长)'</span></span><br></pre></td></tr></table></figure>

<ol>
<li>索引重复</li>
</ol>
<p>np.concatenate 与 pd.concat 最主要的差异之一就是 Pandas 在合并时会保留索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = make_df(<span class="string">'AB'</span>, [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = make_df(<span class="string">'AB'</span>, [<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">y.index = x.index  <span class="comment"># 复制索引</span></span><br><span class="line">print(x); print(y); print(pd.concat([x, y]))</span><br></pre></td></tr></table></figure>

<ul>
<li>捕捉索引重复的错误</li>
</ul>
<p>设置 verify_integrity 参数。将参数设置为 True，合并时若有索引重复就会<br>触发异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    pd.concat([x, y], verify_integrity=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"ValueError:"</span>, e)</span><br></pre></td></tr></table></figure>

<ul>
<li>忽略索引</li>
</ul>
<p>ignore_index</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.concat([x, y], ignore_index=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>增加多级索引</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.concat([x, y], keys=[<span class="string">'x'</span>, <span class="string">'y'</span>]))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>类似join的合并</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df5 = make_df(<span class="string">'ABC'</span>, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">df6 = make_df(<span class="string">'BCD'</span>, [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(df5); print(df6)</span><br><span class="line">print(pd.concat([df5,df6]))</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-28-4310d251cd1d&gt; in &lt;module&gt;
----&gt; 1 df5 = make_df(&apos;ABC&apos;, [1, 2])
      2 df6 = make_df(&apos;BCD&apos;, [3, 4])
      3 print(df5); print(df6)
      4 print(pd.concat([df5,df6]))


NameError: name &apos;make_df&apos; is not defined</code></pre><p>如果不想让缺失的值被NaN代替。可以用join 和join_axes参数设置合并方式</p>
<p>默认： <code>join = &#39;outer&#39;</code>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.concat([df5, df6], join=<span class="string">'inner'</span>))</span><br></pre></td></tr></table></figure>

<p>另一种合并方式是直接确定结果使用的列名，设置 join_axes 参数，里面是索引对象构成<br>的列表（是列表的列表）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.concat([df5,df6],join_axes = [df5.columns]))</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>append()方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(df1);print(df2);print(df1.append(df2))</span><br></pre></td></tr></table></figure>

<ul>
<li>注： pandas的append()不直接更新原有对象的值，而是为合并后的数据创建一个新对象，因此并不高效。</li>
</ul>
<h1 id="合并数据集：-合并与连接"><a href="#合并数据集：-合并与连接" class="headerlink" title="合并数据集： 合并与连接"></a>合并数据集： 合并与连接</h1><h2 id="数据连接"><a href="#数据连接" class="headerlink" title="数据连接"></a>数据连接</h2><ol>
<li>一对一</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'employee'</span>: [<span class="string">'Bob'</span>, <span class="string">'Jake'</span>, <span class="string">'Lisa'</span>, <span class="string">'Sue'</span>],</span><br><span class="line"><span class="string">'group'</span>: [<span class="string">'Accounting'</span>, <span class="string">'Engineering'</span>, <span class="string">'Engineering'</span>, <span class="string">'HR'</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'employee'</span>: [<span class="string">'Lisa'</span>, <span class="string">'Bob'</span>, <span class="string">'Jake'</span>, <span class="string">'Sue'</span>],</span><br><span class="line"><span class="string">'hire_date'</span>: [<span class="number">2004</span>, <span class="number">2008</span>, <span class="number">2012</span>, <span class="number">2014</span>]&#125;)</span><br><span class="line">print(df1); print(df2)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df3 = pd.merge(df1,df2)</span><br><span class="line">df3</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>多对一</li>
</ol>
<p>在需要连接的两个列中，有一列的值有重复</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df4 = pd.DataFrame(&#123;<span class="string">'group'</span>: [<span class="string">'Accounting'</span>, <span class="string">'Engineering'</span>, <span class="string">'HR'</span>],</span><br><span class="line"><span class="string">'supervisor'</span>: [<span class="string">'Carly'</span>, <span class="string">'Guido'</span>, <span class="string">'Steve'</span>]&#125;)</span><br><span class="line">print(df3); print(df4); print(pd.merge(df3, df4))</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>多对多</li>
</ol>
<p>左右两个输入的同列都包含重复值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df5 = pd.DataFrame(&#123;<span class="string">'group'</span>: [<span class="string">'Accounting'</span>, <span class="string">'Accounting'</span>,</span><br><span class="line">                    <span class="string">'Engineering'</span>, <span class="string">'Engineering'</span>, <span class="string">'HR'</span>, <span class="string">'HR'</span>],</span><br><span class="line"><span class="string">'skills'</span>: [<span class="string">'math'</span>, <span class="string">'spreadsheets'</span>, <span class="string">'coding'</span>, <span class="string">'linux'</span>,</span><br><span class="line">           <span class="string">'spreadsheets'</span>, <span class="string">'organization'</span>]&#125;)</span><br><span class="line">print(df1); print(df5); print(pd.merge(df1, df5))</span><br></pre></td></tr></table></figure>

<h2 id="设置数据合并的键"><a href="#设置数据合并的键" class="headerlink" title="设置数据合并的键"></a>设置数据合并的键</h2><ol>
<li>on参数：将on参数设置为一个列名字符串或者一个包含多列名称的列表</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(df1)</span><br><span class="line">print(df2)</span><br><span class="line">print(pd.merge(df1,df2))</span><br><span class="line">print(pd.merge(df1,df2,on = <span class="string">'employee'</span>))</span><br></pre></td></tr></table></figure>

<p>这个参数只能在两个 DataFrame 有共同列名的时候才可以使用。</p>
<ol start="2">
<li>left_on 与right_on参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df3 = pd.DataFrame(&#123;<span class="string">'name'</span>: [<span class="string">'Bob'</span>, <span class="string">'Jake'</span>, <span class="string">'Lisa'</span>, <span class="string">'Sue'</span>],</span><br><span class="line"><span class="string">'salary'</span>: [<span class="number">70000</span>, <span class="number">80000</span>, <span class="number">120000</span>, <span class="number">90000</span>]&#125;)</span><br><span class="line">print(df1);</span><br><span class="line">print(df3)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.merge(df1,df3,left_on = <span class="string">'employee'</span>,right_on = <span class="string">'name'</span>))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(df1, df3, left_on=<span class="string">"employee"</span>, right_on=<span class="string">"name"</span>).drop(<span class="string">'name'</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>left_index 与 right_index 参数</li>
</ol>
<p>合并索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df1a = df1.set_index(<span class="string">'employee'</span>)</span><br><span class="line">df2a = df2.set_index(<span class="string">'employee'</span>)</span><br><span class="line">print(df1a)</span><br><span class="line">print(df2a)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.merge(df1a,df2a,left_index = <span class="literal">True</span>, right_index = <span class="literal">True</span>))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1a.join(df2a)</span><br></pre></td></tr></table></figure>

<p>索引与列混合使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.merge(df1a, df3, left_index=<span class="literal">True</span>, right_on=<span class="string">'name'</span>))</span><br></pre></td></tr></table></figure>

<h2 id="设置数据连接的集合操作规则"><a href="#设置数据连接的集合操作规则" class="headerlink" title="设置数据连接的集合操作规则"></a>设置数据连接的集合操作规则</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df6 = pd.DataFrame(&#123;<span class="string">'name'</span>: [<span class="string">'Peter'</span>, <span class="string">'Paul'</span>, <span class="string">'Mary'</span>],</span><br><span class="line">                    <span class="string">'food'</span>: [<span class="string">'fish'</span>, <span class="string">'beans'</span>, <span class="string">'bread'</span>]&#125;,</span><br><span class="line">                    columns=[<span class="string">'name'</span>, <span class="string">'food'</span>])</span><br><span class="line">df7 = pd.DataFrame(&#123;<span class="string">'name'</span>: [<span class="string">'Mary'</span>, <span class="string">'Joseph'</span>],</span><br><span class="line">                    <span class="string">'drink'</span>: [<span class="string">'wine'</span>, <span class="string">'beer'</span>]&#125;,</span><br><span class="line">                    columns=[<span class="string">'name'</span>, <span class="string">'drink'</span>])</span><br><span class="line">print(df6);print(); print(df7); print();print(pd.merge(df6, df7))</span><br></pre></td></tr></table></figure>

<p>默认情况下，结果中只会包含两个输入集合的交集，这种连接方式被称为内连接（inner join）</p>
<p>改为外连接：how = ‘outer’</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.merge(df6,df7,how = <span class="string">'outer'</span>))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.merge(df6, df7, how=<span class="string">'left'</span>))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.merge(df6, df7, how=<span class="string">'right'</span>))</span><br></pre></td></tr></table></figure>

<p>现在输出的行中只包含左边输入列的值。如果用 how=’right’ 的话，输出的行则只包含右<br>边输入列的值。</p>
<h2 id="重复列名：suffixes"><a href="#重复列名：suffixes" class="headerlink" title="重复列名：suffixes"></a>重复列名：suffixes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df8 = pd.DataFrame(&#123;<span class="string">'name'</span>: [<span class="string">'Bob'</span>, <span class="string">'Jake'</span>, <span class="string">'Lisa'</span>, <span class="string">'Sue'</span>],</span><br><span class="line">                    <span class="string">'rank'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line">df9 = pd.DataFrame(&#123;<span class="string">'name'</span>: [<span class="string">'Bob'</span>, <span class="string">'Jake'</span>, <span class="string">'Lisa'</span>, <span class="string">'Sue'</span>],</span><br><span class="line">                    <span class="string">'rank'</span>: [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]&#125;)</span><br><span class="line">print(df8); print(df9); print(pd.merge(df8, df9, on=<span class="string">"name"</span>))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过suffixes参数自定义后缀名</span></span><br><span class="line">print(df8); print(df9);</span><br><span class="line">print(pd.merge(df8, df9, on=<span class="string">"name"</span>, suffixes=[<span class="string">"_L"</span>, <span class="string">"_R"</span>]))</span><br></pre></td></tr></table></figure>

<h1 id="分组与累计"><a href="#分组与累计" class="headerlink" title="分组与累计"></a>分组与累计</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">42</span>)</span><br><span class="line">ser = pd.Series(rng.rand(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser</span><br></pre></td></tr></table></figure>




<pre><code>0    0.374540
1    0.950714
2    0.731994
3    0.598658
4    0.156019
dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser.sum()</span><br></pre></td></tr></table></figure>




<pre><code>2.811925491708157</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DataFrame</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'A'</span>:rng.rand(<span class="number">5</span>),<span class="string">'B'</span>:rng.rand(<span class="number">5</span>)&#125;)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.155995</td>
      <td>0.020584</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.058084</td>
      <td>0.969910</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.866176</td>
      <td>0.832443</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.601115</td>
      <td>0.212339</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.708073</td>
      <td>0.181825</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.mean()</span><br></pre></td></tr></table></figure>




<pre><code>A    0.477888
B    0.443420
dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.mean(axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>0    0.088290
1    0.513997
2    0.849309
3    0.406727
4    0.444949
dtype: float64</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">指标| 描述</span><br><span class="line">-|-</span><br><span class="line">count() |计数项</span><br><span class="line">first()、 last() |第一项与最后一项</span><br><span class="line">mean()、 median() |均值与中位数</span><br><span class="line">min()、 max() |最小值与最大值</span><br><span class="line">std()、 var() |标准差与方差</span><br><span class="line">mad() |均值绝对偏差（mean absolute deviation）</span><br><span class="line">prod() |所有项乘积</span><br><span class="line">sum() |所有项求和</span><br><span class="line"></span><br><span class="line">## GroupBy：分隔、应用、组合</span><br><span class="line"></span><br><span class="line">1. 分隔、应用和组合</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">df &#x3D; pd.DataFrame(&#123;&#39;key&#39;: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;],</span><br><span class="line">                    &#39;data&#39;: range(6)&#125;, columns&#x3D;[&#39;key&#39;, &#39;data&#39;])</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>data</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>A</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>B</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>C</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>A</td>
      <td>3</td>
    </tr>
    <tr>
      <th>4</th>
      <td>B</td>
      <td>4</td>
    </tr>
    <tr>
      <th>5</th>
      <td>C</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">'key'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&lt;pandas.core.groupby.groupby.DataFrameGroupBy object at 0x0000027627AED1D0&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">'key'</span>).sum()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>data</th>
    </tr>
    <tr>
      <th>key</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>3</td>
    </tr>
    <tr>
      <th>B</th>
      <td>5</td>
    </tr>
    <tr>
      <th>C</th>
      <td>7</td>
    </tr>
  </tbody>
</table>
</div>



<p>可以用 Pandas 或 NumPy 的任意一种累计函数，也<br>可以用任意有效的 DataFrame 对象。</p>
<ol start="2">
<li>GroupBy对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">planets = sns.load_dataset(<span class="string">'planets'</span>)</span><br><span class="line">planets.shape</span><br></pre></td></tr></table></figure>




<pre><code>(1035, 6)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">planets.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>method</th>
      <th>number</th>
      <th>orbital_period</th>
      <th>mass</th>
      <th>distance</th>
      <th>year</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Radial Velocity</td>
      <td>1</td>
      <td>269.300</td>
      <td>7.10</td>
      <td>77.40</td>
      <td>2006</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Radial Velocity</td>
      <td>1</td>
      <td>874.774</td>
      <td>2.21</td>
      <td>56.95</td>
      <td>2008</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Radial Velocity</td>
      <td>1</td>
      <td>763.000</td>
      <td>2.60</td>
      <td>19.84</td>
      <td>2011</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Radial Velocity</td>
      <td>1</td>
      <td>326.030</td>
      <td>19.40</td>
      <td>110.62</td>
      <td>2007</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Radial Velocity</td>
      <td>1</td>
      <td>516.220</td>
      <td>10.50</td>
      <td>119.47</td>
      <td>2009</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">planets.dropna().describe()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>number</th>
      <th>orbital_period</th>
      <th>mass</th>
      <th>distance</th>
      <th>year</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>498.00000</td>
      <td>498.000000</td>
      <td>498.000000</td>
      <td>498.000000</td>
      <td>498.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>1.73494</td>
      <td>835.778671</td>
      <td>2.509320</td>
      <td>52.068213</td>
      <td>2007.377510</td>
    </tr>
    <tr>
      <th>std</th>
      <td>1.17572</td>
      <td>1469.128259</td>
      <td>3.636274</td>
      <td>46.596041</td>
      <td>4.167284</td>
    </tr>
    <tr>
      <th>min</th>
      <td>1.00000</td>
      <td>1.328300</td>
      <td>0.003600</td>
      <td>1.350000</td>
      <td>1989.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>1.00000</td>
      <td>38.272250</td>
      <td>0.212500</td>
      <td>24.497500</td>
      <td>2005.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>1.00000</td>
      <td>357.000000</td>
      <td>1.245000</td>
      <td>39.940000</td>
      <td>2009.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>2.00000</td>
      <td>999.600000</td>
      <td>2.867500</td>
      <td>59.332500</td>
      <td>2011.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>6.00000</td>
      <td>17337.500000</td>
      <td>25.000000</td>
      <td>354.000000</td>
      <td>2014.000000</td>
    </tr>
  </tbody>
</table>
</div>



<ul>
<li>按列取值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">planets.groupby(<span class="string">'method'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&lt;pandas.core.groupby.groupby.DataFrameGroupBy object at 0x0000027629029EF0&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">planets.groupby(<span class="string">'method'</span>)[<span class="string">'orbital_period'</span>]</span><br></pre></td></tr></table></figure>




<pre><code>&lt;pandas.core.groupby.groupby.SeriesGroupBy object at 0x000002762A05A198&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">planets.groupby(<span class="string">'method'</span>)[<span class="string">'orbital_period'</span>].median()</span><br></pre></td></tr></table></figure>




<pre><code>method
Astrometry                         631.180000
Eclipse Timing Variations         4343.500000
Imaging                          27500.000000
Microlensing                      3300.000000
Orbital Brightness Modulation        0.342887
Pulsar Timing                       66.541900
Pulsation Timing Variations       1170.000000
Radial Velocity                    360.200000
Transit                              5.714932
Transit Timing Variations           57.011000
Name: orbital_period, dtype: float64</code></pre><ul>
<li><p>按组迭代</p>
<p>GroupBy 对象支持直接按组进行迭代，返回的每一组都是 Series 或 DataFrame：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (method,group) <span class="keyword">in</span> planets.groupby(<span class="string">'method'</span>):</span><br><span class="line">    print(<span class="string">"&#123;0:30s&#125; shape = &#123;1&#125;"</span>.format(method, group.shape))</span><br></pre></td></tr></table></figure>

<pre><code>Astrometry                     shape = (2, 6)
Eclipse Timing Variations      shape = (9, 6)
Imaging                        shape = (38, 6)
Microlensing                   shape = (23, 6)
Orbital Brightness Modulation  shape = (3, 6)
Pulsar Timing                  shape = (5, 6)
Pulsation Timing Variations    shape = (1, 6)
Radial Velocity                shape = (553, 6)
Transit                        shape = (397, 6)
Transit Timing Variations      shape = (4, 6)</code></pre><ul>
<li>调用方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">planets.groupby(<span class="string">'method'</span>)[<span class="string">"year"</span>].describe().unstack()</span><br></pre></td></tr></table></figure>




<pre><code>       method                       
count  Astrometry                          2.000000
       Eclipse Timing Variations           9.000000
       Imaging                            38.000000
       Microlensing                       23.000000
       Orbital Brightness Modulation       3.000000
       Pulsar Timing                       5.000000
       Pulsation Timing Variations         1.000000
       Radial Velocity                   553.000000
       Transit                           397.000000
       Transit Timing Variations           4.000000
mean   Astrometry                       2011.500000
       Eclipse Timing Variations        2010.000000
       Imaging                          2009.131579
       Microlensing                     2009.782609
       Orbital Brightness Modulation    2011.666667
       Pulsar Timing                    1998.400000
       Pulsation Timing Variations      2007.000000
       Radial Velocity                  2007.518987
       Transit                          2011.236776
       Transit Timing Variations        2012.500000
std    Astrometry                          2.121320
       Eclipse Timing Variations           1.414214
       Imaging                             2.781901
       Microlensing                        2.859697
       Orbital Brightness Modulation       1.154701
       Pulsar Timing                       8.384510
       Pulsation Timing Variations              NaN
       Radial Velocity                     4.249052
       Transit                             2.077867
       Transit Timing Variations           1.290994
                                           ...     
50%    Astrometry                       2011.500000
       Eclipse Timing Variations        2010.000000
       Imaging                          2009.000000
       Microlensing                     2010.000000
       Orbital Brightness Modulation    2011.000000
       Pulsar Timing                    1994.000000
       Pulsation Timing Variations      2007.000000
       Radial Velocity                  2009.000000
       Transit                          2012.000000
       Transit Timing Variations        2012.500000
75%    Astrometry                       2012.250000
       Eclipse Timing Variations        2011.000000
       Imaging                          2011.000000
       Microlensing                     2012.000000
       Orbital Brightness Modulation    2012.000000
       Pulsar Timing                    2003.000000
       Pulsation Timing Variations      2007.000000
       Radial Velocity                  2011.000000
       Transit                          2013.000000
       Transit Timing Variations        2013.250000
max    Astrometry                       2013.000000
       Eclipse Timing Variations        2012.000000
       Imaging                          2013.000000
       Microlensing                     2013.000000
       Orbital Brightness Modulation    2013.000000
       Pulsar Timing                    2011.000000
       Pulsation Timing Variations      2007.000000
       Radial Velocity                  2014.000000
       Transit                          2014.000000
       Transit Timing Variations        2014.000000
Length: 80, dtype: float64</code></pre><ol start="3">
<li>累计、过滤、转换和应用</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">0</span>)</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'key'</span> : [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>],</span><br><span class="line">                  <span class="string">'data1'</span>: range(<span class="number">6</span>),</span><br><span class="line">                  <span class="string">'data2'</span>: rng.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">6</span>)&#125;,</span><br><span class="line">                  columns = [<span class="string">'key'</span>,<span class="string">'data1'</span>,<span class="string">'data2'</span>])</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>A</td>
      <td>0</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>B</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>C</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>A</td>
      <td>3</td>
      <td>3</td>
    </tr>
    <tr>
      <th>4</th>
      <td>B</td>
      <td>4</td>
      <td>7</td>
    </tr>
    <tr>
      <th>5</th>
      <td>C</td>
      <td>5</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>



<ul>
<li>累计</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">'key'</span>).aggregate([<span class="string">'min'</span>,np.median,max])</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead tr th {
    text-align: left;
}

.dataframe thead tr:last-of-type th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="3" halign="left">data1</th>
      <th colspan="3" halign="left">data2</th>
    </tr>
    <tr>
      <th></th>
      <th>min</th>
      <th>median</th>
      <th>max</th>
      <th>min</th>
      <th>median</th>
      <th>max</th>
    </tr>
    <tr>
      <th>key</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>0</td>
      <td>1.5</td>
      <td>3</td>
      <td>3</td>
      <td>4.0</td>
      <td>5</td>
    </tr>
    <tr>
      <th>B</th>
      <td>1</td>
      <td>2.5</td>
      <td>4</td>
      <td>0</td>
      <td>3.5</td>
      <td>7</td>
    </tr>
    <tr>
      <th>C</th>
      <td>2</td>
      <td>3.5</td>
      <td>5</td>
      <td>3</td>
      <td>6.0</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">'key'</span>).aggregate(&#123;<span class="string">'data1'</span>:<span class="string">'min'</span>,<span class="string">'data2'</span>:max&#125;)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>data1</th>
      <th>data2</th>
    </tr>
    <tr>
      <th>key</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>0</td>
      <td>5</td>
    </tr>
    <tr>
      <th>B</th>
      <td>1</td>
      <td>7</td>
    </tr>
    <tr>
      <th>C</th>
      <td>2</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>



<ul>
<li>过滤</li>
</ul>
<p>过滤操作可以让你按照分组的属性丢弃若干数据。例如，我们可能只需要保留标<br>准差超过某个阈值的组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter_func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="string">'data2'</span>].std()&gt;<span class="number">4</span></span><br><span class="line">print(df); print(df.groupby(<span class="string">'key'</span>).std());<span class="comment">#标准差</span></span><br><span class="line">print(df.groupby(<span class="string">'key'</span>).filter(filter_func))</span><br></pre></td></tr></table></figure>

<pre><code>  key  data1  data2
0   A      0      5
1   B      1      0
2   C      2      3
3   A      3      3
4   B      4      7
5   C      5      9
       data1     data2
key                   
A    2.12132  1.414214
B    2.12132  4.949747
C    2.12132  4.242641
  key  data1  data2
1   B      1      0
2   C      2      3
4   B      4      7
5   C      5      9</code></pre><ul>
<li>转换</li>
</ul>
<p>累计操作返回的是对组内全量数据缩减过的结果，而转换操作会返回一个新的全量数据。数据经过转换之后，其形状与原来的输入数据是一样的。常见的例子就是将每一组的样本数据减去各组的均值，实现数据标准化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">'key'</span>).transform(<span class="keyword">lambda</span> x: x - x.mean())</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-1.5</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-1.5</td>
      <td>-3.5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-1.5</td>
      <td>-3.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1.5</td>
      <td>-1.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1.5</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>5</th>
      <td>1.5</td>
      <td>3.0</td>
    </tr>
  </tbody>
</table>
</div>



<ul>
<li>apply（） 方法</li>
</ul>
<p>apply() 方法让你可以在每个组上应用任意方法。这个函数输入一个<br>DataFrame，返回一个 Pandas 对象（DataFrame 或 Series）或一个标量（scalar，单个数<br>值）。组合操作会适应返回结果类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">norm_by_data2</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="comment"># x是一个分组数据的DataFrame</span></span><br><span class="line">    x[<span class="string">'data1'</span>] /= x[<span class="string">'data2'</span>].sum()</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">print(df); print(df.groupby(<span class="string">'key'</span>).apply(norm_by_data2))</span><br></pre></td></tr></table></figure>

<pre><code>  key  data1  data2
0   A      0      5
1   B      1      0
2   C      2      3
3   A      3      3
4   B      4      7
5   C      5      9
  key     data1  data2
0   A  0.000000      5
1   B  0.142857      0
2   C  0.166667      3
3   A  0.375000      3
4   B  0.571429      7
5   C  0.416667      9</code></pre><ol start="4">
<li>设置分隔的键</li>
</ol>
<ul>
<li>将列表、 数组、 Series 或索引作为分组键 </li>
</ul>
<p>分组键可以是长度与 DataFrame 匹配的任意Series 或列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">print(df);print(df.groupby(L).sum())</span><br></pre></td></tr></table></figure>

<pre><code>  key  data1  data2
0   A      0      5
1   B      1      0
2   C      2      3
3   A      3      3
4   B      4      7
5   C      5      9
   data1  data2
0      7     17
1      4      3
2      4      7</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(df); print(df.groupby(df[<span class="string">'key'</span>]).sum())</span><br></pre></td></tr></table></figure>

<pre><code>  key  data1  data2
0   A      0      5
1   B      1      0
2   C      2      3
3   A      3      3
4   B      4      7
5   C      5      9
     data1  data2
key              
A        3      8
B        5      7
C        7     12</code></pre><ul>
<li>用字典或 Series 将索引映射到分组名称。另一种方法是提供一个字典，将索引映射到分组键：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df2 = df.set_index(<span class="string">'key'</span>)</span><br><span class="line">mapping = &#123;<span class="string">'A'</span>: <span class="string">'vowel'</span>, <span class="string">'B'</span>: <span class="string">'consonant'</span>, <span class="string">'C'</span>: <span class="string">'consonant'</span>&#125;</span><br><span class="line">print(df2); print(df2.groupby(mapping).sum())</span><br></pre></td></tr></table></figure>

<pre><code>     data1  data2
key              
A        0      5
B        1      0
C        2      3
A        3      3
B        4      7
C        5      9
           data1  data2
consonant     12     19
vowel          3      8</code></pre><ul>
<li>任意 Python 函数。与前面的字典映射类似，你可以将任意 Python 函数传入 groupby，<br>函数映射到索引，然后新的分组输出：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(df2); print(df2.groupby(str.lower).mean())</span><br></pre></td></tr></table></figure>

<pre><code>     data1  data2
key              
A        0      5
B        1      0
C        2      3
A        3      3
B        4      7
C        5      9
   data1  data2
a    1.5    4.0
b    2.5    3.5
c    3.5    6.0</code></pre><ul>
<li>多个有效键构成的列表。此外，任意之前有效的键都可以组合起来进行分组，从而返回一个多级索引的分组结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2.groupby([str.lower, mapping]).mean()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <th>vowel</th>
      <td>1.5</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>b</th>
      <th>consonant</th>
      <td>2.5</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>c</th>
      <th>consonant</th>
      <td>3.5</td>
      <td>6.0</td>
    </tr>
  </tbody>
</table>
</div>



<h1 id="数据透视表"><a href="#数据透视表" class="headerlink" title="数据透视表"></a>数据透视表</h1><p>数据透视表更像是一种多维的 GroupBy 累计操作。也就<br>是说，虽然你也可以分割 - 应用 - 组合，但是分割与组合不是发生在一维索引上，而是在<br>二维网格上（行列同时分组）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">titanic = sns.load_dataset(<span class="string">'titanic'</span>)</span><br><span class="line">titanic.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>survived</th>
      <th>pclass</th>
      <th>sex</th>
      <th>age</th>
      <th>sibsp</th>
      <th>parch</th>
      <th>fare</th>
      <th>embarked</th>
      <th>class</th>
      <th>who</th>
      <th>adult_male</th>
      <th>deck</th>
      <th>embark_town</th>
      <th>alive</th>
      <th>alone</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>3</td>
      <td>male</td>
      <td>22.0</td>
      <td>1</td>
      <td>0</td>
      <td>7.2500</td>
      <td>S</td>
      <td>Third</td>
      <td>man</td>
      <td>True</td>
      <td>NaN</td>
      <td>Southampton</td>
      <td>no</td>
      <td>False</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>1</td>
      <td>female</td>
      <td>38.0</td>
      <td>1</td>
      <td>0</td>
      <td>71.2833</td>
      <td>C</td>
      <td>First</td>
      <td>woman</td>
      <td>False</td>
      <td>C</td>
      <td>Cherbourg</td>
      <td>yes</td>
      <td>False</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>3</td>
      <td>female</td>
      <td>26.0</td>
      <td>0</td>
      <td>0</td>
      <td>7.9250</td>
      <td>S</td>
      <td>Third</td>
      <td>woman</td>
      <td>False</td>
      <td>NaN</td>
      <td>Southampton</td>
      <td>yes</td>
      <td>True</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>1</td>
      <td>female</td>
      <td>35.0</td>
      <td>1</td>
      <td>0</td>
      <td>53.1000</td>
      <td>S</td>
      <td>First</td>
      <td>woman</td>
      <td>False</td>
      <td>C</td>
      <td>Southampton</td>
      <td>yes</td>
      <td>False</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>3</td>
      <td>male</td>
      <td>35.0</td>
      <td>0</td>
      <td>0</td>
      <td>8.0500</td>
      <td>S</td>
      <td>Third</td>
      <td>man</td>
      <td>True</td>
      <td>NaN</td>
      <td>Southampton</td>
      <td>no</td>
      <td>True</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titanic.groupby(<span class="string">'sex'</span>)[[<span class="string">'survived'</span>]].mean()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>survived</th>
    </tr>
    <tr>
      <th>sex</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>female</th>
      <td>0.742038</td>
    </tr>
    <tr>
      <th>male</th>
      <td>0.188908</td>
    </tr>
  </tbody>
</table>
</div>



<h1 id="自制数据透视表"><a href="#自制数据透视表" class="headerlink" title="自制数据透视表"></a>自制数据透视表</h1><p>将船舱等级（’class’）与<br>性别（’sex’） 分组，然后选择生还状态（’survived’）列， 应用均值（’mean’）累计函<br>数，再将各组结果组合，最后通过行索引转列索引操作将最里层的行索引转换成列索引，<br>形成二维数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titanic.groupby([<span class="string">'sex'</span>, <span class="string">'class'</span>])[<span class="string">'survived'</span>].aggregate(<span class="string">'mean'</span>).unstack()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>class</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
    </tr>
    <tr>
      <th>sex</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>female</th>
      <td>0.968085</td>
      <td>0.921053</td>
      <td>0.500000</td>
    </tr>
    <tr>
      <th>male</th>
      <td>0.368852</td>
      <td>0.157407</td>
      <td>0.135447</td>
    </tr>
  </tbody>
</table>
</div>



<h2 id="数据透视表语法"><a href="#数据透视表语法" class="headerlink" title="数据透视表语法"></a>数据透视表语法</h2><p>用 DataFrame 的 pivot_table 实现的效果等同于上一节的管道命令的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titanic.pivot_table(<span class="string">'survived'</span>, index = <span class="string">'sex'</span>, columns = <span class="string">'class'</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>class</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
    </tr>
    <tr>
      <th>sex</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>female</th>
      <td>0.968085</td>
      <td>0.921053</td>
      <td>0.500000</td>
    </tr>
    <tr>
      <th>male</th>
      <td>0.368852</td>
      <td>0.157407</td>
      <td>0.135447</td>
    </tr>
  </tbody>
</table>
</div>



<ol>
<li>多级数据透视表</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age = pd.cut(titanic[<span class="string">'age'</span>],[<span class="number">0</span>,<span class="number">18</span>,<span class="number">80</span>])</span><br><span class="line">titanic.pivot_table(<span class="string">'survived'</span>,[<span class="string">'sex'</span>,age],<span class="string">'class'</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>class</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
    </tr>
    <tr>
      <th>sex</th>
      <th>age</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">female</th>
      <th>(0, 18]</th>
      <td>0.909091</td>
      <td>1.000000</td>
      <td>0.511628</td>
    </tr>
    <tr>
      <th>(18, 80]</th>
      <td>0.972973</td>
      <td>0.900000</td>
      <td>0.423729</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">male</th>
      <th>(0, 18]</th>
      <td>0.800000</td>
      <td>0.600000</td>
      <td>0.215686</td>
    </tr>
    <tr>
      <th>(18, 80]</th>
      <td>0.375000</td>
      <td>0.071429</td>
      <td>0.133663</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fare = pd.qcut(titanic[<span class="string">'fare'</span>], <span class="number">2</span>)</span><br><span class="line">titanic.pivot_table(<span class="string">'survived'</span>, [<span class="string">'sex'</span>, age], [fare, <span class="string">'class'</span>])</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead tr th {
    text-align: left;
}

.dataframe thead tr:last-of-type th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>fare</th>
      <th colspan="3" halign="left">(-0.001, 14.454]</th>
      <th colspan="3" halign="left">(14.454, 512.329]</th>
    </tr>
    <tr>
      <th></th>
      <th>class</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
    </tr>
    <tr>
      <th>sex</th>
      <th>age</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">female</th>
      <th>(0, 18]</th>
      <td>NaN</td>
      <td>1.000000</td>
      <td>0.714286</td>
      <td>0.909091</td>
      <td>1.000000</td>
      <td>0.318182</td>
    </tr>
    <tr>
      <th>(18, 80]</th>
      <td>NaN</td>
      <td>0.880000</td>
      <td>0.444444</td>
      <td>0.972973</td>
      <td>0.914286</td>
      <td>0.391304</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">male</th>
      <th>(0, 18]</th>
      <td>NaN</td>
      <td>0.000000</td>
      <td>0.260870</td>
      <td>0.800000</td>
      <td>0.818182</td>
      <td>0.178571</td>
    </tr>
    <tr>
      <th>(18, 80]</th>
      <td>0.0</td>
      <td>0.098039</td>
      <td>0.125000</td>
      <td>0.391304</td>
      <td>0.030303</td>
      <td>0.192308</td>
    </tr>
  </tbody>
</table>
</div>



<ol start="2">
<li>其他数据透视表选项</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pandas 0.18版的函数签名</span></span><br><span class="line">DataFrame.pivot_table(data, values=<span class="literal">None</span>, index=<span class="literal">None</span>, columns=<span class="literal">None</span>,</span><br><span class="line">aggfunc=<span class="string">'mean'</span>, fill_value=<span class="literal">None</span>, margins=<span class="literal">False</span>,</span><br><span class="line">dropna=<span class="literal">True</span>, margins_name=<span class="string">'All'</span>)</span><br></pre></td></tr></table></figure>

<p>aggfunc 参数用于设置累计函数类型，默认值是均值（mean）。与 GroupBy 的用法一样，累计函数可以用一些常见的字符串（’sum’、 ‘mean’、 ‘count’、 ‘min’、 ‘max’ 等）表示，也可以用标准的累计函数（np.sum()、 min()、 sum() 等）表示。另外，还可以通过字典为不同的列指定不同的累计函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">titanic.pivot_table(index=<span class="string">'sex'</span>, columns=<span class="string">'class'</span>,</span><br><span class="line">aggfunc=&#123;<span class="string">'survived'</span>:sum, <span class="string">'fare'</span>:<span class="string">'mean'</span>&#125;)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead tr th {
    text-align: left;
}

.dataframe thead tr:last-of-type th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="3" halign="left">fare</th>
      <th colspan="3" halign="left">survived</th>
    </tr>
    <tr>
      <th>class</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
    </tr>
    <tr>
      <th>sex</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>female</th>
      <td>106.125798</td>
      <td>21.970121</td>
      <td>16.118810</td>
      <td>91</td>
      <td>70</td>
      <td>72</td>
    </tr>
    <tr>
      <th>male</th>
      <td>67.226127</td>
      <td>19.741782</td>
      <td>12.661633</td>
      <td>45</td>
      <td>17</td>
      <td>47</td>
    </tr>
  </tbody>
</table>
</div>



<p>当需要计算每一组的总数时，可以通过 margins 参数来设置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titanic.pivot_table(<span class="string">'survived'</span>, index=<span class="string">'sex'</span>, columns=<span class="string">'class'</span>, margins=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>class</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
      <th>All</th>
    </tr>
    <tr>
      <th>sex</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>female</th>
      <td>0.968085</td>
      <td>0.921053</td>
      <td>0.500000</td>
      <td>0.742038</td>
    </tr>
    <tr>
      <th>male</th>
      <td>0.368852</td>
      <td>0.157407</td>
      <td>0.135447</td>
      <td>0.188908</td>
    </tr>
    <tr>
      <th>All</th>
      <td>0.629630</td>
      <td>0.472826</td>
      <td>0.242363</td>
      <td>0.383838</td>
    </tr>
  </tbody>
</table>
</div>



<h1 id="向量化字符串操作"><a href="#向量化字符串操作" class="headerlink" title="向量化字符串操作"></a>向量化字符串操作</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>])</span><br><span class="line">x * <span class="number">2</span></span><br></pre></td></tr></table></figure>




<pre><code>array([ 4,  6, 10, 14, 22, 26])</code></pre><p>由于 NumPy 并没有为字符串数组提供简单的接口，因此需要<br>通过繁琐的 for 循环来解决问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="string">'peter'</span>, <span class="string">'Paul'</span>, <span class="string">'MARY'</span>, <span class="string">'gUIDO'</span>]</span><br><span class="line">[s.capitalize() <span class="keyword">for</span> s <span class="keyword">in</span> data]</span><br></pre></td></tr></table></figure>




<pre><code>[&apos;Peter&apos;, &apos;Paul&apos;, &apos;Mary&apos;, &apos;Guido&apos;]</code></pre><p>这种处理在遇到缺失值时会失效</p>
<p>Pandas 为包含字符串的 Series 和 Index 对象提供的 str 属性堪称两全其美的方法，它既<br>可以满足向量化字符串操作的需求，又可以正确地处理缺失值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">names = pd.Series(data)</span><br><span class="line">names</span><br></pre></td></tr></table></figure>




<pre><code>0    peter
1     Paul
2     MARY
3    gUIDO
dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.str.capitalize()</span><br></pre></td></tr></table></figure>




<pre><code>0    Peter
1     Paul
2     Mary
3    Guido
dtype: object</code></pre><h2 id="字符串方法列表"><a href="#字符串方法列表" class="headerlink" title="字符串方法列表"></a>字符串方法列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">monte = pd.Series([<span class="string">'Graham Chapman'</span>, <span class="string">'John Cleese'</span>, <span class="string">'Terry Gilliam'</span>,</span><br><span class="line"><span class="string">'Eric Idle'</span>, <span class="string">'Terry Jones'</span>, <span class="string">'Michael Palin'</span>])</span><br></pre></td></tr></table></figure>

<ol>
<li>与python相似</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">len() lower() translate() islower()  </span><br><span class="line">ljust() upper() startswith() isupper()  </span><br><span class="line">rjust() find() endswith() isnumeric()  </span><br><span class="line">center() rfind() isalnum() isdecimal()  </span><br><span class="line">zfill() index() isalpha() split()  </span><br><span class="line">strip() rindex() isdigit() rsplit()  </span><br><span class="line">rstrip() capitalize() isspace() partition()  </span><br><span class="line">lstrip() swapcase() istitle() rpartition()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>正则化表达式</p>
</li>
<li><p>其他字符串方法</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>get()</td>
<td>获取元素索引位置上的值，索引从 0 开始</td>
</tr>
<tr>
<td>slice()</td>
<td>对元素进行切片取值</td>
</tr>
<tr>
<td>slice_replace()</td>
<td>对元素进行切片替换</td>
</tr>
<tr>
<td>cat()</td>
<td></td>
</tr>
<tr>
<td>repeat()</td>
<td>重复元素</td>
</tr>
<tr>
<td>normalize()</td>
<td>将字符串转换为 Unicode 规范形式</td>
</tr>
<tr>
<td>pad()</td>
<td>在字符串的左边、右边或两边增加空格</td>
</tr>
<tr>
<td>wrap()</td>
<td>将字符串按照指定的宽度换行</td>
</tr>
<tr>
<td>join()</td>
<td>用分隔符连接 Series 的每个元素</td>
</tr>
<tr>
<td>get_dummies()</td>
<td>按照分隔符提取每个元素的 dummy 变量，转换为独热（one-hot）编码的 DataFrame</td>
</tr>
</tbody></table>
<ul>
<li>以下两语句效果相同</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monte.str.slice(<span class="number">0</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>




<pre><code>0    Gra
1    Joh
2    Ter
3    Eri
4    Ter
5    Mic
dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monte.str[<span class="number">0</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>




<pre><code>0    Gra
1    Joh
2    Ter
3    Eri
4    Ter
5    Mic
dtype: object</code></pre><p>当你的数据有一列<br>包含了若干已被编码的指标（coded indicator）时，<code>get_dummies()</code>方法就能派上用场了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">full_monte = pd.DataFrame(&#123;<span class="string">'name'</span>: monte,</span><br><span class="line">    <span class="string">'info'</span>: [<span class="string">'B|C|D'</span>, <span class="string">'B|D'</span>, <span class="string">'A|C'</span>, <span class="string">'B|D'</span>, <span class="string">'B|C'</span>,</span><br><span class="line">    <span class="string">'B|C|D'</span>]&#125;)</span><br><span class="line">full_monte</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>info</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Graham Chapman</td>
      <td>B|C|D</td>
    </tr>
    <tr>
      <th>1</th>
      <td>John Cleese</td>
      <td>B|D</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Terry Gilliam</td>
      <td>A|C</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Eric Idle</td>
      <td>B|D</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Terry Jones</td>
      <td>B|C</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Michael Palin</td>
      <td>B|C|D</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">full_monte[<span class="string">'info'</span>].str.get_dummies(<span class="string">'|'</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



<h1 id="处理时间序列"><a href="#处理时间序列" class="headerlink" title="处理时间序列"></a>处理时间序列</h1><ul>
<li>时间戳： 表示某个具体时间点</li>
<li>时间间隔与周期</li>
<li>时间增量或持续时间</li>
</ul>
<h2 id="python的日期与时间"><a href="#python的日期与时间" class="headerlink" title="python的日期与时间"></a>python的日期与时间</h2><ol>
<li>datetime 与dateutil</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建日期</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">datetime(year=<span class="number">2015</span>, month=<span class="number">7</span>, day=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>




<pre><code>datetime.datetime(2015, 7, 4, 0, 0)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对字符串格式的日期进行解析</span></span><br><span class="line"><span class="keyword">from</span> dateutil <span class="keyword">import</span> parser</span><br><span class="line">date = parser.parse(<span class="string">"4th of July, 2015"</span>)</span><br><span class="line">date</span><br></pre></td></tr></table></figure>




<pre><code>datetime.datetime(2015, 7, 4, 0, 0)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date.strftime(<span class="string">'%A'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&apos;Saturday&apos;</code></pre><ol start="2">
<li>Numpy的datetime64</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">date = np.array(<span class="string">'2015-07-04'</span>, dtype=np.datetime64)</span><br><span class="line">date</span><br></pre></td></tr></table></figure>




<pre><code>array(&apos;2015-07-04&apos;, dtype=&apos;datetime64[D]&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date + np.arange(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([&apos;2015-07-04&apos;, &apos;2015-07-05&apos;, &apos;2015-07-06&apos;, &apos;2015-07-07&apos;,
       &apos;2015-07-08&apos;, &apos;2015-07-09&apos;, &apos;2015-07-10&apos;, &apos;2015-07-11&apos;,
       &apos;2015-07-12&apos;, &apos;2015-07-13&apos;, &apos;2015-07-14&apos;, &apos;2015-07-15&apos;],
      dtype=&apos;datetime64[D]&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以分钟为单位</span></span><br><span class="line">date = np.datetime64(<span class="string">'2015-07-04 12:00'</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date + np.arange(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([&apos;2015-07-04T12:00&apos;, &apos;2015-07-04T12:01&apos;, &apos;2015-07-04T12:02&apos;,
       &apos;2015-07-04T12:03&apos;, &apos;2015-07-04T12:04&apos;, &apos;2015-07-04T12:05&apos;,
       &apos;2015-07-04T12:06&apos;, &apos;2015-07-04T12:07&apos;, &apos;2015-07-04T12:08&apos;,
       &apos;2015-07-04T12:09&apos;, &apos;2015-07-04T12:10&apos;, &apos;2015-07-04T12:11&apos;],
      dtype=&apos;datetime64[m]&apos;)</code></pre><ol start="3">
<li>pandas 的日期与时间</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date = pd.to_datetime(<span class="string">"4th of July, 2015"</span>)</span><br><span class="line">date</span><br></pre></td></tr></table></figure>




<pre><code>Timestamp(&apos;2015-07-04 00:00:00&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date.strftime(<span class="string">'%A'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&apos;Saturday&apos;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date + pd.to_timedelta(np.arange(<span class="number">12</span>), <span class="string">'D'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>DatetimeIndex([&apos;2015-07-04&apos;, &apos;2015-07-05&apos;, &apos;2015-07-06&apos;, &apos;2015-07-07&apos;,
               &apos;2015-07-08&apos;, &apos;2015-07-09&apos;, &apos;2015-07-10&apos;, &apos;2015-07-11&apos;,
               &apos;2015-07-12&apos;, &apos;2015-07-13&apos;, &apos;2015-07-14&apos;, &apos;2015-07-15&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=None)</code></pre><h2 id="Pandas时间序列"><a href="#Pandas时间序列" class="headerlink" title="Pandas时间序列"></a>Pandas时间序列</h2><p>Pandas 时间序列工具非常适合用来处理带时间戳的索引数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index = pd.DatetimeIndex([<span class="string">'2014-07-04'</span>, <span class="string">'2014-08-04'</span>,</span><br><span class="line">                         <span class="string">'2015-07-04'</span>, <span class="string">'2015-08-04'</span>])</span><br><span class="line">data = pd.Series([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index = index)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>




<pre><code>2014-07-04    0
2014-08-04    1
2015-07-04    2
2015-08-04    3
dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'2014-07-04'</span>:<span class="string">'2015-07-04'</span>]</span><br></pre></td></tr></table></figure>




<pre><code>2014-07-04    0
2014-08-04    1
2015-07-04    2
dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'2015'</span>]</span><br></pre></td></tr></table></figure>




<pre><code>2015-07-04    2
2015-08-04    3
dtype: int64</code></pre><h2 id="Pandas时间序列数据结构"><a href="#Pandas时间序列数据结构" class="headerlink" title="Pandas时间序列数据结构"></a>Pandas时间序列数据结构</h2><ul>
<li>时间戳数据： <code>Timestamp</code></li>
<li>时间周期：<code>Period</code></li>
<li>时间增量和持续时间：<code>Timedelta</code></li>
</ul>
<p>最基础的日期 / 时间对象是 Timestamp 和 DatetimeIndex。这两种对象可以直接使用，最常用<br>的方法是 pd.to_datetime() 函数，它可以解析许多日期与时间格式。对 pd.to_datetime() 传<br>递一个日期会返回一个 Timestamp 类型，传递一个时间序列会返回一个 DatetimeIndex 类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.to_datetime([datetime(<span class="number">2015</span>, <span class="number">7</span>, <span class="number">3</span>), <span class="string">'4th of July, 2015'</span>,<span class="string">'2015-Jul-6'</span>, <span class="string">'07-07-2015'</span>, <span class="string">'20150708'</span>])</span><br><span class="line">dates</span><br></pre></td></tr></table></figure>




<pre><code>DatetimeIndex([&apos;2015-07-03&apos;, &apos;2015-07-04&apos;, &apos;2015-07-06&apos;, &apos;2015-07-07&apos;,
               &apos;2015-07-08&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=None)</code></pre><p>任何 DatetimeIndex 类型都可以通过 to_period() 方法和一个频率代码转换成 PeriodIndex<br>类型。下面用 ‘D’ 将数据转换成单日的时间序列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dates.to_period(<span class="string">'D'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>PeriodIndex([&apos;2015-07-03&apos;, &apos;2015-07-04&apos;, &apos;2015-07-06&apos;, &apos;2015-07-07&apos;,
             &apos;2015-07-08&apos;],
            dtype=&apos;period[D]&apos;, freq=&apos;D&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dates - dates[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>




<pre><code>TimedeltaIndex([&apos;0 days&apos;, &apos;1 days&apos;, &apos;3 days&apos;, &apos;4 days&apos;, &apos;5 days&apos;], dtype=&apos;timedelta64[ns]&apos;, freq=None)</code></pre><p>为了能更简便地创建有规律的时间序列， Pandas 提供了一些方法： pd.date_range() 可以<br>处理时间戳、 pd.period_range() 可以处理周期、 pd.timedelta_range() 可以处理时间间<br>隔。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.date_range(<span class="string">'2015-07-03'</span>, <span class="string">'2015-07-10'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>DatetimeIndex([&apos;2015-07-03&apos;, &apos;2015-07-04&apos;, &apos;2015-07-05&apos;, &apos;2015-07-06&apos;,
               &apos;2015-07-07&apos;, &apos;2015-07-08&apos;, &apos;2015-07-09&apos;, &apos;2015-07-10&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.date_range(<span class="string">'2015-07-03'</span>, periods=<span class="number">8</span>)</span><br></pre></td></tr></table></figure>




<pre><code>DatetimeIndex([&apos;2015-07-03&apos;, &apos;2015-07-04&apos;, &apos;2015-07-05&apos;, &apos;2015-07-06&apos;,
               &apos;2015-07-07&apos;, &apos;2015-07-08&apos;, &apos;2015-07-09&apos;, &apos;2015-07-10&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># D:day H: hour</span></span><br><span class="line">pd.date_range(<span class="string">'2015-07-03'</span>, periods=<span class="number">8</span>, freq=<span class="string">'H'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>DatetimeIndex([&apos;2015-07-03 00:00:00&apos;, &apos;2015-07-03 01:00:00&apos;,
               &apos;2015-07-03 02:00:00&apos;, &apos;2015-07-03 03:00:00&apos;,
               &apos;2015-07-03 04:00:00&apos;, &apos;2015-07-03 05:00:00&apos;,
               &apos;2015-07-03 06:00:00&apos;, &apos;2015-07-03 07:00:00&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=&apos;H&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.period_range(<span class="string">'2015-07'</span>, periods=<span class="number">8</span>, freq=<span class="string">'M'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>PeriodIndex([&apos;2015-07&apos;, &apos;2015-08&apos;, &apos;2015-09&apos;, &apos;2015-10&apos;, &apos;2015-11&apos;, &apos;2015-12&apos;,
             &apos;2016-01&apos;, &apos;2016-02&apos;],
            dtype=&apos;period[M]&apos;, freq=&apos;M&apos;)</code></pre><h2 id="时间频率与偏移量"><a href="#时间频率与偏移量" class="headerlink" title="时间频率与偏移量"></a>时间频率与偏移量</h2><table>
<thead>
<tr>
<th>代码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>D</td>
<td>天</td>
</tr>
<tr>
<td>W</td>
<td>周</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>Q</td>
<td>季度</td>
</tr>
<tr>
<td>A</td>
<td>年</td>
</tr>
<tr>
<td>H</td>
<td>小时</td>
</tr>
<tr>
<td>T</td>
<td>分钟</td>
</tr>
<tr>
<td>S</td>
<td>秒</td>
</tr>
<tr>
<td>B</td>
<td>天（只含工作日）</td>
</tr>
<tr>
<td>BH</td>
<td>小时（只含工作小时）</td>
</tr>
</tbody></table>
<p>月、季、年频率都是具体周期的结束时间（月末、季末、年末），而有一些以 S（start，开<br>始）为后缀的代码表示日期开始</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>频率</th>
</tr>
</thead>
<tbody><tr>
<td>MS</td>
<td>月初（month start）</td>
</tr>
<tr>
<td>BMS</td>
<td>月初（business month start，仅含工作日）</td>
</tr>
<tr>
<td>QS</td>
<td>季初（quarter start）</td>
</tr>
<tr>
<td>BQS</td>
<td>季初（business quarter start，仅含工作日）</td>
</tr>
<tr>
<td>AS</td>
<td>年初（year start）</td>
</tr>
<tr>
<td>BAS</td>
<td>年初（business year start，仅含工作日）</td>
</tr>
</tbody></table>
<p>另外，你可以在频率代码后面加三位月份缩写字母来改变季、年频率的开始时间。<br>• Q-JAN、 BQ-FEB、 QS-MAR、 BQS-APR 等。<br>• A-JAN、 BA-FEB、 AS-MAR、 BAS-APR 等。<br>同理，也可以在后面加三位星期缩写字母来改变一周的开始时间。<br>• W-SUN、 W-MON、 W-TUE、 W-WED 等。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.timedelta_range(<span class="number">0</span>, periods=<span class="number">9</span>, freq=<span class="string">"2H30T"</span>)</span><br></pre></td></tr></table></figure>




<pre><code>TimedeltaIndex([&apos;00:00:00&apos;, &apos;02:30:00&apos;, &apos;05:00:00&apos;, &apos;07:30:00&apos;, &apos;10:00:00&apos;,
                &apos;12:30:00&apos;, &apos;15:00:00&apos;, &apos;17:30:00&apos;, &apos;20:00:00&apos;],
               dtype=&apos;timedelta64[ns]&apos;, freq=&apos;150T&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> BDay</span><br><span class="line">pd.date_range(<span class="string">'2015-07-01'</span>, periods=<span class="number">5</span>, freq=BDay())</span><br></pre></td></tr></table></figure>




<pre><code>DatetimeIndex([&apos;2015-07-01&apos;, &apos;2015-07-02&apos;, &apos;2015-07-03&apos;, &apos;2015-07-06&apos;,
               &apos;2015-07-07&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=&apos;B&apos;)</code></pre>
    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/16/%E4%BC%9A%E8%AE%A1%E5%AD%A6/%E6%80%BB%E8%AE%BA/" rel="prev" title="会计学/总论">
      <i class="fa fa-chevron-left"></i> 会计学/总论
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/21/%E4%BC%9A%E8%AE%A1%E5%AD%A6/%E4%BC%9A%E8%AE%A1%E6%A0%B8%E7%AE%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="next" title="会计学/会计核算基础知识">
      会计学/会计核算基础知识 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Pandas-基本数据结构"><span class="nav-number">1.</span> <span class="nav-text">Pandas 基本数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Series-对象"><span class="nav-number">1.1.</span> <span class="nav-text">Series 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Serise是通用的NumPy数组"><span class="nav-number">1.1.1.</span> <span class="nav-text">Serise是通用的NumPy数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Series是特殊的字典"><span class="nav-number">1.1.2.</span> <span class="nav-text">Series是特殊的字典</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建Serise对象"><span class="nav-number">1.1.3.</span> <span class="nav-text">创建Serise对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataFrame-对象"><span class="nav-number">1.2.</span> <span class="nav-text">DataFrame 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DataFrame是通用的NumPy数组"><span class="nav-number">1.2.1.</span> <span class="nav-text">DataFrame是通用的NumPy数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DataFrame是特殊的字典"><span class="nav-number">1.2.2.</span> <span class="nav-text">DataFrame是特殊的字典</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建DataFrame对象"><span class="nav-number">1.2.3.</span> <span class="nav-text">创建DataFrame对象</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pandas的Index对象"><span class="nav-number">1.3.</span> <span class="nav-text">Pandas的Index对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#将Index看作不可变数组"><span class="nav-number">1.3.1.</span> <span class="nav-text">将Index看作不可变数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将Index看作有序集合"><span class="nav-number">1.3.2.</span> <span class="nav-text">将Index看作有序集合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据取值与选择"><span class="nav-number">2.</span> <span class="nav-text">数据取值与选择</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Series-数据选择方法"><span class="nav-number">2.1.</span> <span class="nav-text">Series 数据选择方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DataFrame数据选择方法"><span class="nav-number">2.2.</span> <span class="nav-text">DataFrame数据选择方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pandas数值运算方法"><span class="nav-number">3.</span> <span class="nav-text">Pandas数值运算方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#通用函数：保留索引"><span class="nav-number">3.1.</span> <span class="nav-text">通用函数：保留索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通用函数：索引对齐"><span class="nav-number">3.2.</span> <span class="nav-text">通用函数：索引对齐</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通用函数：DataFrame与Series的运算"><span class="nav-number">3.3.</span> <span class="nav-text">通用函数：DataFrame与Series的运算</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#处理缺失值"><span class="nav-number">4.</span> <span class="nav-text">处理缺失值</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#处理缺失值-1"><span class="nav-number">4.1.</span> <span class="nav-text">处理缺失值</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多级索引"><span class="nav-number">5.</span> <span class="nav-text">多级索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#多级索引Series"><span class="nav-number">5.1.</span> <span class="nav-text">多级索引Series</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多级索引的创建方法"><span class="nav-number">5.2.</span> <span class="nav-text">多级索引的创建方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多级索引的取值与切片"><span class="nav-number">5.3.</span> <span class="nav-text">多级索引的取值与切片</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多级索引行列转换"><span class="nav-number">5.4.</span> <span class="nav-text">多级索引行列转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多级索引的数据累计方法"><span class="nav-number">5.5.</span> <span class="nav-text">多级索引的数据累计方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#合并数据集：Concat与Append操作"><span class="nav-number">6.</span> <span class="nav-text">合并数据集：Concat与Append操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#pd-concat方法"><span class="nav-number">6.1.</span> <span class="nav-text">pd.concat方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#合并数据集：-合并与连接"><span class="nav-number">7.</span> <span class="nav-text">合并数据集： 合并与连接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据连接"><span class="nav-number">7.1.</span> <span class="nav-text">数据连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置数据合并的键"><span class="nav-number">7.2.</span> <span class="nav-text">设置数据合并的键</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置数据连接的集合操作规则"><span class="nav-number">7.3.</span> <span class="nav-text">设置数据连接的集合操作规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重复列名：suffixes"><span class="nav-number">7.4.</span> <span class="nav-text">重复列名：suffixes</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#分组与累计"><span class="nav-number">8.</span> <span class="nav-text">分组与累计</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据透视表"><span class="nav-number">9.</span> <span class="nav-text">数据透视表</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#自制数据透视表"><span class="nav-number">10.</span> <span class="nav-text">自制数据透视表</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据透视表语法"><span class="nav-number">10.1.</span> <span class="nav-text">数据透视表语法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#向量化字符串操作"><span class="nav-number">11.</span> <span class="nav-text">向量化字符串操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">11.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串方法列表"><span class="nav-number">11.2.</span> <span class="nav-text">字符串方法列表</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#处理时间序列"><span class="nav-number">12.</span> <span class="nav-text">处理时间序列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#python的日期与时间"><span class="nav-number">12.1.</span> <span class="nav-text">python的日期与时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pandas时间序列"><span class="nav-number">12.2.</span> <span class="nav-text">Pandas时间序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pandas时间序列数据结构"><span class="nav-number">12.3.</span> <span class="nav-text">Pandas时间序列数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时间频率与偏移量"><span class="nav-number">12.4.</span> <span class="nav-text">时间频率与偏移量</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">luyilin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        </script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luyilin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
