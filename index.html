<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"luyilin.top","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="引而不发，跃如也">
<meta property="og:url" content="http://luyilin.top/index.html">
<meta property="og:site_name" content="引而不发，跃如也">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="luyilin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://luyilin.top/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>引而不发，跃如也</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">引而不发，跃如也</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://luyilin.top/2020/09/22/C%E5%92%8C%E6%8C%87%E9%92%88/05%20%E5%87%BD%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="luyilin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="引而不发，跃如也">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/22/C%E5%92%8C%E6%8C%87%E9%92%88/05%20%E5%87%BD%E6%95%B0/" class="post-title-link" itemprop="url">C和指针/05 函数</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-22 10:11:30" itemprop="dateCreated datePublished" datetime="2020-09-22T10:11:30+08:00">2020-09-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://luyilin.top/2020/09/21/%E4%BC%9A%E8%AE%A1%E5%AD%A6/%E4%BC%9A%E8%AE%A1%E6%A0%B8%E7%AE%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="luyilin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="引而不发，跃如也">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/21/%E4%BC%9A%E8%AE%A1%E5%AD%A6/%E4%BC%9A%E8%AE%A1%E6%A0%B8%E7%AE%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">会计学/会计核算基础知识</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-21 21:12:01" itemprop="dateCreated datePublished" datetime="2020-09-21T21:12:01+08:00">2020-09-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-23 09:10:34" itemprop="dateModified" datetime="2020-09-23T09:10:34+08:00">2020-09-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BC%9A%E8%AE%A1%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">会计学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="会计核算基础知识"><a href="#会计核算基础知识" class="headerlink" title="会计核算基础知识"></a>会计核算基础知识</h1><h2 id="会计要素与会计等式"><a href="#会计要素与会计等式" class="headerlink" title="会计要素与会计等式"></a>会计要素与会计等式</h2><p><img src="/2020/09/21/%E4%BC%9A%E8%AE%A1%E5%AD%A6/%E4%BC%9A%E8%AE%A1%E6%A0%B8%E7%AE%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20200921194808540.png" alt="image-20200921194808540"></p>
<h3 id="会计要素"><a href="#会计要素" class="headerlink" title="会计要素"></a>会计要素</h3><p>会计要素是会计对象的具体化，是对会计核算和监督内容的基本分类</p>
<ul>
<li>资产</li>
<li>负债</li>
<li>所有者权益（净资产）</li>
<li>收入</li>
<li>费用</li>
<li>利润</li>
</ul>
<h3 id="会计等式"><a href="#会计等式" class="headerlink" title="会计等式"></a>会计等式</h3><p>资产 = 权益</p>
<p>资产 = 负债 + 所有者权益</p>
<p>收入 - 费用 = 利润</p>
<p>资产 = 负债 + 所有者权益 + （收入 - 费用）</p>
<p><img src="/2020/09/21/%E4%BC%9A%E8%AE%A1%E5%AD%A6/%E4%BC%9A%E8%AE%A1%E6%A0%B8%E7%AE%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20200921195141305.png" alt="image-20200921195141305"></p>
<h2 id="会计科目和账户"><a href="#会计科目和账户" class="headerlink" title="会计科目和账户"></a>会计科目和账户</h2><h3 id="会计科目"><a href="#会计科目" class="headerlink" title="会计科目"></a>会计科目</h3><p>会计科目对会计要素的具体内容进一步分类的项目名称</p>
<ol>
<li>资产类</li>
<li>负债类</li>
<li>所有者权益类</li>
<li>费用类</li>
<li>损益类</li>
</ol>
<p>按照核算的详略程度不同，分为总分类科目和明细科目</p>
<h3 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h3><p>账户是根据会计科目开设的，具有一定的格式和结构，用于分类、系统、连续的纪录经济业务的一种工具</p>
<p>账户应该包括的基本内容：</p>
<ol>
<li>账户名称，即会计科目</li>
<li>经济业务发生的日期</li>
<li>据以等级的会计凭证号数</li>
<li>经济业务的内容摘要</li>
<li>增加或减少的金额</li>
</ol>
<h3 id="复式记账法"><a href="#复式记账法" class="headerlink" title="复式记账法"></a>复式记账法</h3><blockquote>
<p>预收收入不是收入是负债</p>
<p>预付费用不是费用是资产</p>
</blockquote>
<p>理论依据：会计等式</p>
<p>能够全面、清晰的反应经济业务的全貌</p>
<table>
<thead>
<tr>
<th></th>
<th>借方</th>
<th>贷方</th>
</tr>
</thead>
<tbody><tr>
<td>资产类账户</td>
<td>+</td>
<td>-</td>
</tr>
<tr>
<td>负债及所有者权益</td>
<td>-</td>
<td>+</td>
</tr>
<tr>
<td>费用类账户</td>
<td>+</td>
<td>-</td>
</tr>
<tr>
<td>收入类账户</td>
<td>-</td>
<td>+</td>
</tr>
<tr>
<td>分红</td>
<td>-</td>
<td>+</td>
</tr>
</tbody></table>
<p>​    所有者权益 </p>
<p>= 实收资本 + 留存收益 </p>
<p>= 实收资本 + 期初留存收益 + 当期净收益 - 分红</p>
<p>= 实收资本 + 期初留存收益 + 收入 - 费用 - 分红</p>
<blockquote>
<p>有借必有贷，借贷必相等</p>
</blockquote>
<ul>
<li>借贷记账法：</li>
</ul>
<ol>
<li>对每一笔经济业务都必须同时计入两个或两个以上相互联系的账户，并且以借贷相反的方向登记入账，使得经济业务之间形成<strong>应借，应贷的相互依存关系</strong></li>
<li>每一项经济业务计入借方的金额同计入贷方的金额必须相等</li>
</ol>
<ul>
<li>试算平衡</li>
</ul>
<ol>
<li><p>每笔会计分录的试算平衡</p>
<p>借方科目金额 = 贷方科目金额</p>
</li>
<li><p>全部账户本期发生频额试算平衡</p>
<p>全部账户借方发生额合计 = 全部账户贷方发生额合计</p>
</li>
<li><p>全部账户期末余额试算平衡</p>
<p>全部账户借方余额合计 = 全部账户贷方余额合计</p>
</li>
</ol>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><img src="/2020/09/21/%E4%BC%9A%E8%AE%A1%E5%AD%A6/%E4%BC%9A%E8%AE%A1%E6%A0%B8%E7%AE%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20200921204336633.png" alt="image-20200921204336633"></p>
<ol>
<li><p>借：银行存款 5000</p>
<p>贷：现金 5000</p>
</li>
<li><p>借：材料 20000元</p>
<p>贷：应付账款 20000元</p>
</li>
<li><p>借：贷款50万</p>
<p>贷：银行存款50万</p>
</li>
<li><p>借：短期贷款20万</p>
<p>贷：长期贷款20万</p>
</li>
<li><p>借：应付账款8000</p>
<p>贷：银行存款8000</p>
</li>
<li><p>借：固定资产25万</p>
<p>贷：银行存款25万</p>
</li>
</ol>
<p><img src="/2020/09/21/%E4%BC%9A%E8%AE%A1%E5%AD%A6/%E4%BC%9A%E8%AE%A1%E6%A0%B8%E7%AE%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20200921210338018.png" alt="image-20200921210338018"></p>
<p><img src="/2020/09/21/%E4%BC%9A%E8%AE%A1%E5%AD%A6/%E4%BC%9A%E8%AE%A1%E6%A0%B8%E7%AE%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20200921210444595.png" alt="image-20200921210444595"></p>
<h1 id="会计循环"><a href="#会计循环" class="headerlink" title="会计循环"></a>会计循环</h1><h2 id="基本程序"><a href="#基本程序" class="headerlink" title="基本程序"></a>基本程序</h2><p><img src="/2020/09/21/%E4%BC%9A%E8%AE%A1%E5%AD%A6/%E4%BC%9A%E8%AE%A1%E6%A0%B8%E7%AE%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20200921210714541.png" alt="image-20200921210714541"></p>
<ul>
<li><p>期末账项调整 </p>
<ol>
<li>收入项目调整：登记应收收入，调整预收收入</li>
<li>费用项目调整：登记应计费用，调整预付费用</li>
</ol>
</li>
<li><p>对账与结账</p>
<ul>
<li>对账: 在过账之后，保证账簿纪录的正确性。账证核对，账账核对，账实核对</li>
<li>结账：结转本期的成本与费用，结转本期实现的各项收入和利得，结转其他账户</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/21/%E4%BC%9A%E8%AE%A1%E5%AD%A6/%E4%BC%9A%E8%AE%A1%E6%A0%B8%E7%AE%97%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-20200923090503885.png" alt="image-20200923090503885"></p>
<ul>
<li>试算平衡</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://luyilin.top/2020/09/18/Python/Pandas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="luyilin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="引而不发，跃如也">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/18/Python/Pandas/" class="post-title-link" itemprop="url">Python/Pandas</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-18 17:21:55 / Modified: 17:22:32" itemprop="dateCreated datePublished" datetime="2020-09-18T17:21:55+08:00">2020-09-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">pd.__version__</span><br></pre></td></tr></table></figure>




<pre><code>&apos;0.23.4&apos;</code></pre><h1 id="Pandas-基本数据结构"><a href="#Pandas-基本数据结构" class="headerlink" title="Pandas 基本数据结构"></a>Pandas 基本数据结构</h1><h2 id="Series-对象"><a href="#Series-对象" class="headerlink" title="Series 对象"></a>Series 对象</h2><p>Pandas 的 Series 对象是一个带索引数据构成的一维数组。可以用一个数组创建 Series 对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.Series([<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1.0</span>])</span><br><span class="line">data</span><br></pre></td></tr></table></figure>




<pre><code>0    0.25
1    0.50
2    0.75
3    1.00
dtype: float64</code></pre><p>Series 对象将一组数据和一组索引绑定在一起，我们可以通过 values 属性和 index 属性获取数据。values 属性返回的结果与 NumPy 数组类似</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.values</span><br></pre></td></tr></table></figure>




<pre><code>array([0.25, 0.5 , 0.75, 1.  ])</code></pre><p>index 属性返回的结果是一个类型为 pd.Index 的类数组对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.index</span><br></pre></td></tr></table></figure>




<pre><code>RangeIndex(start=0, stop=4, step=1)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line">data[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>




<pre><code>1    0.50
2    0.75
dtype: float64</code></pre><h3 id="Serise是通用的NumPy数组"><a href="#Serise是通用的NumPy数组" class="headerlink" title="Serise是通用的NumPy数组"></a>Serise是通用的NumPy数组</h3><p>NumPy 数组通过隐式定义的整数索引获取数值，而 Pandas 的 Series 对象用一种显式定义的索引与数值关联，因此，Serise的索引不仅仅可以是整数，还可以是其他任意类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = pd.Series([<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1.0</span>],</span><br><span class="line">                        index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line">data[<span class="string">'b'</span>]</span><br></pre></td></tr></table></figure>




<pre><code>0.5</code></pre><h3 id="Series是特殊的字典"><a href="#Series是特殊的字典" class="headerlink" title="Series是特殊的字典"></a>Series是特殊的字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">population_dict = &#123;<span class="string">'California'</span>: <span class="number">38332521</span>,</span><br><span class="line">                           <span class="string">'Texas'</span>: <span class="number">26448193</span>,</span><br><span class="line">                           <span class="string">'New York'</span>: <span class="number">19651127</span>,</span><br><span class="line">                           <span class="string">'Florida'</span>: <span class="number">19552860</span>,</span><br><span class="line">                           <span class="string">'Illinois'</span>: <span class="number">12882135</span>&#125;</span><br><span class="line">population = pd.Series(population_dict)</span><br><span class="line">population</span><br></pre></td></tr></table></figure>




<pre><code>California    38332521
Texas         26448193
New York      19651127
Florida       19552860
Illinois      12882135
dtype: int64</code></pre><p>和字典不同，Series 对象还支持数组形式的操作，比如切片</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">population[<span class="string">'California'</span>:<span class="string">'New York'</span>]</span><br></pre></td></tr></table></figure>




<pre><code>California    38332521
Texas         26448193
New York      19651127
dtype: int64</code></pre><h3 id="创建Serise对象"><a href="#创建Serise对象" class="headerlink" title="创建Serise对象"></a>创建Serise对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用   pd.Series(data, index=index)</span></span><br><span class="line"><span class="comment"># 字典</span></span><br><span class="line">pd.Series(&#123;<span class="number">2</span>:<span class="string">'a'</span>, <span class="number">1</span>:<span class="string">'b'</span>, <span class="number">3</span>:<span class="string">'c'</span>&#125;)</span><br></pre></td></tr></table></figure>




<pre><code>2    a
1    b
3    c
dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.Series(&#123;<span class="number">2</span>:<span class="string">'a'</span>, <span class="number">1</span>:<span class="string">'b'</span>, <span class="number">3</span>:<span class="string">'c'</span>&#125;, index=[<span class="number">3</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>




<pre><code>3    c
2    a
dtype: object</code></pre><h2 id="DataFrame-对象"><a href="#DataFrame-对象" class="headerlink" title="DataFrame 对象"></a>DataFrame 对象</h2><h3 id="DataFrame是通用的NumPy数组"><a href="#DataFrame是通用的NumPy数组" class="headerlink" title="DataFrame是通用的NumPy数组"></a>DataFrame是通用的NumPy数组</h3><p>DataFrame 就可以看作是一种既有灵活的行索引，又有灵活列名的二维数组。可以把 DataFrame 看成是有序排列的若干 Series 对象。这里的“排列”指的是它们拥有共同的索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Series</span></span><br><span class="line">population_dict = &#123;<span class="string">'California'</span>: <span class="number">38332521</span>,</span><br><span class="line">                           <span class="string">'Texas'</span>: <span class="number">26448193</span>,</span><br><span class="line">                           <span class="string">'New York'</span>: <span class="number">19651127</span>,</span><br><span class="line">                           <span class="string">'Florida'</span>: <span class="number">19552860</span>,</span><br><span class="line">                           <span class="string">'Illinois'</span>: <span class="number">12882135</span>&#125;</span><br><span class="line">population = pd.Series(population_dict)</span><br><span class="line"></span><br><span class="line">area_dict = &#123;<span class="string">'California'</span>: <span class="number">423967</span>, <span class="string">'Texas'</span>: <span class="number">695662</span>, <span class="string">'New York'</span>: <span class="number">141297</span>,</span><br><span class="line">             <span class="string">'Florida'</span>: <span class="number">170312</span>, <span class="string">'Illinois'</span>: <span class="number">149995</span>&#125;</span><br><span class="line">area = pd.Series(area_dict)</span><br><span class="line"></span><br><span class="line">population,area</span><br></pre></td></tr></table></figure>




<pre><code>(California    38332521
 Texas         26448193
 New York      19651127
 Florida       19552860
 Illinois      12882135
 dtype: int64,
 California    423967
 Texas         695662
 New York      141297
 Florida       170312
 Illinois      149995
 dtype: int64)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">states = pd.DataFrame(&#123;<span class="string">'Population'</span>: population,</span><br><span class="line">                               <span class="string">'Area'</span>: area&#125;)</span><br><span class="line">states</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Population</th>
      <th>Area</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>California</th>
      <td>38332521</td>
      <td>423967</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>26448193</td>
      <td>695662</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>19651127</td>
      <td>141297</td>
    </tr>
    <tr>
      <th>Florida</th>
      <td>19552860</td>
      <td>170312</td>
    </tr>
    <tr>
      <th>Illinois</th>
      <td>12882135</td>
      <td>149995</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">states.index</span><br></pre></td></tr></table></figure>




<pre><code>Index([&apos;California&apos;, &apos;Texas&apos;, &apos;New York&apos;, &apos;Florida&apos;, &apos;Illinois&apos;], dtype=&apos;object&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存放列标签 </span></span><br><span class="line">states.columns</span><br></pre></td></tr></table></figure>




<pre><code>Index([&apos;Population&apos;, &apos;Area&apos;], dtype=&apos;object&apos;)</code></pre><p>因此 DataFrame 可以看作一种通用的 NumPy 二维数组，它的行与列都可以通过索引获取。</p>
<h3 id="DataFrame是特殊的字典"><a href="#DataFrame是特殊的字典" class="headerlink" title="DataFrame是特殊的字典"></a>DataFrame是特殊的字典</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">states[<span class="string">'Area'</span>]</span><br></pre></td></tr></table></figure>




<pre><code>California    423967
Texas         695662
New York      141297
Florida       170312
Illinois      149995
Name: Area, dtype: int64</code></pre><h3 id="创建DataFrame对象"><a href="#创建DataFrame对象" class="headerlink" title="创建DataFrame对象"></a>创建DataFrame对象</h3><ol>
<li>通过Series对象创建</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(population, columns = [<span class="string">'Population'</span>])</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Population</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>California</th>
      <td>38332521</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>26448193</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>19651127</td>
    </tr>
    <tr>
      <th>Florida</th>
      <td>19552860</td>
    </tr>
    <tr>
      <th>Illinois</th>
      <td>12882135</td>
    </tr>
  </tbody>
</table>
</div>



<ol start="2">
<li>通过字典创建</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = [&#123;<span class="string">'a'</span>: i, <span class="string">'b'</span>: <span class="number">2</span> * i&#125;  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>)]</span><br><span class="line">pd.DataFrame(data)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 缺失值NaN</span></span><br><span class="line">pd.DataFrame([&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;, &#123;<span class="string">'b'</span>: <span class="number">3</span>, <span class="string">'c'</span>: <span class="number">4</span>&#125;])</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1.0</td>
      <td>2</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>NaN</td>
      <td>3</td>
      <td>4.0</td>
    </tr>
  </tbody>
</table>
</div>



<ol start="3">
<li>通过 Series 对象字典创建。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(&#123;<span class="string">'population'</span>: population,<span class="string">'area'</span>: area&#125;)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>population</th>
      <th>area</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>California</th>
      <td>38332521</td>
      <td>423967</td>
    </tr>
    <tr>
      <th>Texas</th>
      <td>26448193</td>
      <td>695662</td>
    </tr>
    <tr>
      <th>New York</th>
      <td>19651127</td>
      <td>141297</td>
    </tr>
    <tr>
      <th>Florida</th>
      <td>19552860</td>
      <td>170312</td>
    </tr>
    <tr>
      <th>Illinois</th>
      <td>12882135</td>
      <td>149995</td>
    </tr>
  </tbody>
</table>
</div>



<ol start="4">
<li>通过 NumPy 二维数组创建。假如有一个二维数组，就可以创建一个可以指定行列索引值的 DataFrame。如果不指定行列索引值，那么行列默认都是整数索引值</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(np.random.rand(<span class="number">3</span>, <span class="number">2</span>),columns=[<span class="string">'foo'</span>, <span class="string">'bar'</span>],</span><br><span class="line">             index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>foo</th>
      <th>bar</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>0.266475</td>
      <td>0.446555</td>
    </tr>
    <tr>
      <th>b</th>
      <td>0.343573</td>
      <td>0.323659</td>
    </tr>
    <tr>
      <th>c</th>
      <td>0.369059</td>
      <td>0.243293</td>
    </tr>
  </tbody>
</table>
</div>



<ol start="5">
<li>通过 NumPy 结构化数组创建</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = np.zeros(<span class="number">3</span>, dtype=[(<span class="string">'A'</span>, <span class="string">'i8'</span>), (<span class="string">'B'</span>, <span class="string">'f8'</span>)])</span><br><span class="line">A</span><br></pre></td></tr></table></figure>




<pre><code>array([(0, 0.), (0, 0.), (0, 0.)], dtype=[(&apos;A&apos;, &apos;&lt;i8&apos;), (&apos;B&apos;, &apos;&lt;f8&apos;)])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(A)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>0.0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0</td>
      <td>0.0</td>
    </tr>
  </tbody>
</table>
</div>



<h2 id="Pandas的Index对象"><a href="#Pandas的Index对象" class="headerlink" title="Pandas的Index对象"></a>Pandas的Index对象</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ind = pd.Index([<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>])</span><br><span class="line">ind</span><br></pre></td></tr></table></figure>




<pre><code>Int64Index([2, 3, 5, 7, 11], dtype=&apos;int64&apos;)</code></pre><h3 id="将Index看作不可变数组"><a href="#将Index看作不可变数组" class="headerlink" title="将Index看作不可变数组"></a>将Index看作不可变数组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ind[<span class="number">1</span>]</span><br></pre></td></tr></table></figure>




<pre><code>3</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ind[::<span class="number">2</span>]</span><br></pre></td></tr></table></figure>




<pre><code>Int64Index([2, 5, 11], dtype=&apos;int64&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(ind.size, ind.shape, ind.ndim, ind.dtype)</span><br></pre></td></tr></table></figure>

<pre><code>5 (5,) 1 int64</code></pre><p>Index 对象与 NumPy 数组之间的不同在于，Index 对象的索引是不可变的，也就是说不能通过通常的方式进行调整：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ind[<span class="number">1</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

TypeError                                 Traceback (most recent call last)

&lt;ipython-input-27-906a9fa1424c&gt; in &lt;module&gt;
----&gt; 1 ind[1] = 0


~\Anaconda3\lib\site-packages\pandas\core\indexes\base.py in __setitem__(self, key, value)
   2063 
   2064     def __setitem__(self, key, value):
-&gt; 2065         raise TypeError(&quot;Index does not support mutable operations&quot;)
   2066 
   2067     def __getitem__(self, key):


TypeError: Index does not support mutable operations</code></pre><h3 id="将Index看作有序集合"><a href="#将Index看作有序集合" class="headerlink" title="将Index看作有序集合"></a>将Index看作有序集合</h3><p> Index 对象遵循 Python 标准库的集合（set）数据结构的许多习惯用法，包括并集、交集、差集等</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">indA = pd.Index([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br><span class="line">indB = pd.Index([<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indA &amp; indB  <span class="comment"># 交集</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indA | indB  <span class="comment"># 并集</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">indA ^ indB  <span class="comment"># 异或</span></span><br></pre></td></tr></table></figure>

<h1 id="数据取值与选择"><a href="#数据取值与选择" class="headerlink" title="数据取值与选择"></a>数据取值与选择</h1><h2 id="Series-数据选择方法"><a href="#Series-数据选择方法" class="headerlink" title="Series 数据选择方法"></a>Series 数据选择方法</h2><p>Series 对象与一维 NumPy 数组和标准 Python 字典在许多方面都一样</p>
<ol>
<li>将Series看做字典</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = pd.Series([<span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1.0</span>],</span><br><span class="line">                 index=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line">data[<span class="string">'a'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'e'</span>] = <span class="number">1.25</span></span><br><span class="line">data</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将Series看作一维数组</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将显式索引作为切片</span></span><br><span class="line">data[<span class="string">'a'</span>:<span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将隐式整数索引作为切片</span></span><br><span class="line">data[<span class="number">0</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 掩码</span></span><br><span class="line">data[(data &gt; <span class="number">0.3</span>) &amp; (data &lt; <span class="number">0.8</span>)]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 花哨的索引</span></span><br><span class="line">data[[<span class="string">'a'</span>, <span class="string">'e'</span>]]</span><br></pre></td></tr></table></figure>

<ul>
<li>注： 当使用显式索引（即 data[‘a’:’c’]）作切片时，结果包含最后一个索引；而当使用隐式索引（即 data[0:2]）作切片时，结果不包含最后一个索引。</li>
</ul>
<ol start="3">
<li>索引器：<code>loc</code>、<code>iloc</code>和<code>ix</code></li>
</ol>
<p>如果 Series 是显式整数索引，那么 data[1] 这样的取值操作会使用显式索引，而 data[1:3] 这样的切片操作却会使用隐式索引。会造成混淆。所以 Pandas 提供了一些索引器（indexer）属性来作为取值的方法。它们不是 Series 对象的函数方法，而是暴露切片接口的属性。</p>
<pre><code>1. loc属性，表示取值和切片都是显式的</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.Series([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], index=[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br><span class="line">data</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.loc[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<pre><code>2. iloc,表示取值和切片都是 Python 形式的隐式索引</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.iloc[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<pre><code>3.ix, 它是前两种索引器的混合形式，在 Series 对象中 ix 等价于标准的 []（Python 列表）取值方式。ix 索引器主要用于 DataFrame 对象</code></pre><h2 id="DataFrame数据选择方法"><a href="#DataFrame数据选择方法" class="headerlink" title="DataFrame数据选择方法"></a>DataFrame数据选择方法</h2><ol>
<li>将DataFrame看作字典</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">area = pd.Series(&#123;<span class="string">'California'</span>: <span class="number">423967</span>, <span class="string">'Texas'</span>: <span class="number">695662</span>,</span><br><span class="line">                          <span class="string">'New York'</span>: <span class="number">141297</span>, <span class="string">'Florida'</span>: <span class="number">170312</span>,</span><br><span class="line">                          <span class="string">'Illinois'</span>: <span class="number">149995</span>&#125;)</span><br><span class="line">pop = pd.Series(&#123;<span class="string">'California'</span>: <span class="number">38332521</span>, <span class="string">'Texas'</span>: <span class="number">26448193</span>,</span><br><span class="line">                         <span class="string">'New York'</span>: <span class="number">19651127</span>, <span class="string">'Florida'</span>: <span class="number">19552860</span>,</span><br><span class="line">                         <span class="string">'Illinois'</span>: <span class="number">12882135</span>&#125;)</span><br><span class="line">data = pd.DataFrame(&#123;<span class="string">'area'</span>:area, <span class="string">'pop'</span>:pop&#125;)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'area'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.area</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'density'</span>] = data[<span class="string">'pop'</span>] / data[<span class="string">'area'</span>]</span><br><span class="line">data</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将DataFrame看作二维数组</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.values</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转置</span></span><br><span class="line">data.T</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.values[<span class="number">0</span>]<span class="comment">#第一行</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'area'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.iloc[:<span class="number">3</span>,:<span class="number">2</span>] <span class="comment">#三行两列</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.loc[:<span class="string">'Illinois'</span>, :<span class="string">'pop'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.ix[:<span class="number">3</span>, :<span class="string">'pop'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># loc与花哨索引组合</span></span><br><span class="line">data.loc[data.density &gt; <span class="number">100</span>, [<span class="string">'pop'</span>, <span class="string">'density'</span>]]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>其他取值方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'Florida'</span>:<span class="string">'Illinois'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[data.density &gt; <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<h1 id="Pandas数值运算方法"><a href="#Pandas数值运算方法" class="headerlink" title="Pandas数值运算方法"></a>Pandas数值运算方法</h1><p>对于一元运算（像函数与三角函数），这些通用函数将在输出结果中保留索引和列标签；而对于二元运算（如加法和乘法），Pandas 在传递通用函数时会自动对齐索引进行计算。这就意味着，保存数据内容与组合不同来源的数据——两处在 NumPy 数组中都容易出错的地方——变成了 Pandas 的杀手锏</p>
<h2 id="通用函数：保留索引"><a href="#通用函数：保留索引" class="headerlink" title="通用函数：保留索引"></a>通用函数：保留索引</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">42</span>)</span><br><span class="line">ser = pd.Series(rng.randint(<span class="number">0</span>, <span class="number">10</span>, <span class="number">4</span>))</span><br><span class="line">rng</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(rng.randint(<span class="number">0</span>, <span class="number">10</span>, (<span class="number">3</span>, <span class="number">4</span>)),</span><br><span class="line">                         columns=[<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>])</span><br><span class="line">df</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.exp(ser)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.sin(df * np.pi / <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h2 id="通用函数：索引对齐"><a href="#通用函数：索引对齐" class="headerlink" title="通用函数：索引对齐"></a>通用函数：索引对齐</h2><ol>
<li>Series索引对齐</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">area = pd.Series(&#123;<span class="string">'Alaska'</span>: <span class="number">1723337</span>, <span class="string">'Texas'</span>: <span class="number">695662</span>,</span><br><span class="line">       <span class="string">'California'</span>: <span class="number">423967</span>&#125;, name=<span class="string">'area'</span>)</span><br><span class="line">population = pd.Series(&#123;<span class="string">'California'</span>: <span class="number">38332521</span>, <span class="string">'Texas'</span>: <span class="number">26448193</span>,</span><br><span class="line">       <span class="string">'New York'</span>: <span class="number">19651127</span>&#125;, name=<span class="string">'population'</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">population / area</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>DataFrame索引对齐</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = pd.DataFrame(rng.randint(<span class="number">0</span>, <span class="number">20</span>, (<span class="number">2</span>, <span class="number">2</span>)),</span><br><span class="line">                         columns=list(<span class="string">'AB'</span>))</span><br><span class="line">A</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B = pd.DataFrame(rng.randint(<span class="number">0</span>, <span class="number">10</span>, (<span class="number">3</span>, <span class="number">3</span>)),</span><br><span class="line">                         columns=list(<span class="string">'BAC'</span>))</span><br><span class="line">B</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A+B</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#我们将用 A 中所有值的均值来填充缺失值</span></span><br><span class="line"><span class="comment">#（计算 A 的均值需要用 stack 将二维数组压缩成一维数组）：</span></span><br><span class="line">fill = A.stack().mean()</span><br><span class="line">A.add(B, fill_value=fill)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Python运算符</th>
<th>Pandas方法</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>add()</td>
</tr>
<tr>
<td>-</td>
<td>sub()、subtract()</td>
</tr>
<tr>
<td>*</td>
<td>mul()、multiply()</td>
</tr>
<tr>
<td>/</td>
<td>truediv()、div()、divide()</td>
</tr>
<tr>
<td>//</td>
<td>floordiv()</td>
</tr>
<tr>
<td>%</td>
<td>mod()</td>
</tr>
<tr>
<td>**</td>
<td>pow()</td>
</tr>
</tbody></table>
<h2 id="通用函数：DataFrame与Series的运算"><a href="#通用函数：DataFrame与Series的运算" class="headerlink" title="通用函数：DataFrame与Series的运算"></a>通用函数：DataFrame与Series的运算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = rng.randint(<span class="number">10</span>, size=(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">A</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A - A[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h1 id="处理缺失值"><a href="#处理缺失值" class="headerlink" title="处理缺失值"></a>处理缺失值</h1><ol>
<li>None</li>
</ol>
<p>None 是一个 Python 对象，所以不能作为任何 NumPy / Pandas 数组类型的缺失值，只能用于 ‘object’ 数组类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vals1 = np.array([<span class="number">1</span>, <span class="literal">None</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">vals1</span><br></pre></td></tr></table></figure>

<ul>
<li>注：如 sum() 或者 min()，那么通常会出现类型错误</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vals1.sum()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>NaN:数值类型的缺失值</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vals2 = np.array([<span class="number">1</span>, np.nan, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">vals2.dtype</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + np.nan</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> * np.nan</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vals2.sum(), vals2.min(), vals2.max()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略缺失值</span></span><br><span class="line">np.nansum(vals2), np.nanmin(vals2), np.nanmax(vals2)</span><br></pre></td></tr></table></figure>

<h2 id="处理缺失值-1"><a href="#处理缺失值-1" class="headerlink" title="处理缺失值"></a>处理缺失值</h2><ol>
<li>发现缺失值</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.Series([<span class="number">1</span>, np.nan, <span class="string">'hello'</span>, <span class="literal">None</span>])</span><br><span class="line">data.isnull()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[data.notnull()]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>剔除缺失值</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.dropna()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DataFrame 情形</span></span><br><span class="line">df = pd.DataFrame([[<span class="number">1</span>,      np.nan, <span class="number">2</span>],</span><br><span class="line">                           [<span class="number">2</span>,      <span class="number">3</span>,      <span class="number">5</span>],</span><br><span class="line">                           [np.nan, <span class="number">4</span>,      <span class="number">6</span>]])</span><br><span class="line">df</span><br></pre></td></tr></table></figure>

<p>我们没法从 DataFrame 中单独剔除一个值，要么是剔除缺失值所在的整行，要么是整列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.dropna()<span class="comment">#默认情况下，dropna() 会剔除任何包含缺失值的整行数据</span></span><br></pre></td></tr></table></figure>

<p>通过设置 how 或 thresh 参数来满足，它们可以设置剔除行或列缺失值的数量阈值。</p>
<p>默认设置是 how=’any’，也就是说只要有缺失值就剔除整行或整列（通过 axis 设置坐标轴）。你还可以设置 how=’all’，这样就只会剔除全部是缺失值的行或列了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="number">3</span>] = np.nan</span><br><span class="line">df</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.dropna(axis=<span class="string">'columns'</span>, how=<span class="string">'all'</span>)</span><br></pre></td></tr></table></figure>

<p>还可以通过 thresh 参数设置行或列中非缺失值的最小数量，从而实现更加个性化的配置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.dropna(axis=<span class="string">'rows'</span>, thresh=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>填充缺失值</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.Series([<span class="number">1</span>, np.nan, <span class="number">2</span>, <span class="literal">None</span>, <span class="number">3</span>], index=list(<span class="string">'abcde'</span>))</span><br><span class="line">data</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以用缺失值前面的有效值来从前往后填充（forward-fill）</span></span><br><span class="line">data.fillna(method=<span class="string">'ffill'</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从后往前填充back-fill</span></span><br><span class="line">data.fillna(method=<span class="string">'bfill'</span>)</span><br></pre></td></tr></table></figure>

<p>DataFrame 的操作方法与 Series 类似，只是在填充时需要设置坐标轴参数 axis</p>
<h1 id="多级索引"><a href="#多级索引" class="headerlink" title="多级索引"></a>多级索引</h1><p>将高维数组转换成类似一维 Series 和二维 DataFrame 对象的形式。</p>
<h2 id="多级索引Series"><a href="#多级索引Series" class="headerlink" title="多级索引Series"></a>多级索引Series</h2><ol>
<li>一维情形</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">index = [(<span class="string">'California'</span>, <span class="number">2000</span>), (<span class="string">'California'</span>, <span class="number">2010</span>),</span><br><span class="line">                (<span class="string">'New York'</span>, <span class="number">2000</span>), (<span class="string">'New York'</span>, <span class="number">2010</span>),</span><br><span class="line">                (<span class="string">'Texas'</span>, <span class="number">2000</span>), (<span class="string">'Texas'</span>, <span class="number">2010</span>)]</span><br><span class="line">populations = [<span class="number">33871648</span>, <span class="number">37253956</span>,</span><br><span class="line">              <span class="number">18976457</span>, <span class="number">19378102</span>,</span><br><span class="line">              <span class="number">20851820</span>, <span class="number">25145561</span>]</span><br><span class="line"></span><br><span class="line">index = pd.MultiIndex.from_tuples(index)</span><br><span class="line">index</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop = pd.Series(populations, index=index)</span><br><span class="line">pop</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop[:, <span class="number">2010</span>]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>多维情形</li>
</ol>
<figure class="highlight plain"><figcaption><span>方法可以快速将一个多级索引的``` Series ```转化为普通索引的 ```DataFrame```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">pop_df &#x3D; pop.unstack()</span><br><span class="line">pop_df</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop_df.stack()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pop_df = pd.DataFrame(&#123;<span class="string">'total'</span>: pop,</span><br><span class="line">                       <span class="string">'under18'</span>: [<span class="number">9267089</span>, <span class="number">9284094</span>,</span><br><span class="line">                                   <span class="number">4687374</span>, <span class="number">4318033</span>,</span><br><span class="line">                                   <span class="number">5906301</span>, <span class="number">6879014</span>]&#125;)</span><br><span class="line">pop_df</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f_u18 = pop_df[<span class="string">'under18'</span>] / pop_df[<span class="string">'total'</span>]</span><br><span class="line">f_u18.unstack()</span><br></pre></td></tr></table></figure>

<h2 id="多级索引的创建方法"><a href="#多级索引的创建方法" class="headerlink" title="多级索引的创建方法"></a>多级索引的创建方法</h2><p>为 Series 或 DataFrame 创建多级索引最直接的办法就是将 index 参数设置为至少二维的索引数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.random.rand(<span class="number">4</span>, <span class="number">2</span>),</span><br><span class="line">                index=[[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]],</span><br><span class="line">                columns=[<span class="string">'data1'</span>, <span class="string">'data2'</span>])</span><br><span class="line">df</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典</span></span><br><span class="line">data = &#123;(<span class="string">'California'</span>, <span class="number">2000</span>): <span class="number">33871648</span>,</span><br><span class="line">        (<span class="string">'California'</span>, <span class="number">2010</span>): <span class="number">37253956</span>,</span><br><span class="line">        (<span class="string">'Texas'</span>, <span class="number">2000</span>): <span class="number">20851820</span>,</span><br><span class="line">        (<span class="string">'Texas'</span>, <span class="number">2010</span>): <span class="number">25145561</span>,</span><br><span class="line">        (<span class="string">'New York'</span>, <span class="number">2000</span>): <span class="number">18976457</span>,</span><br><span class="line">        (<span class="string">'New York'</span>, <span class="number">2010</span>): <span class="number">19378102</span>&#125;</span><br><span class="line">pd.Series(data)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>MultiIndex</code> 方法</li>
</ul>
<ol>
<li>显式地创建多级索引</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.MultiIndex.from_arrays(</span><br><span class="line">    [[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.MultiIndex.from_tuples(</span><br><span class="line">    [(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'a'</span>, <span class="number">2</span>), (<span class="string">'b'</span>, <span class="number">1</span>), (<span class="string">'b'</span>, <span class="number">2</span>)])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 笛卡尔积（Cartesian product）</span></span><br><span class="line">pd.MultiIndex.from_product(</span><br><span class="line">    [[<span class="string">'a'</span>, <span class="string">'b'</span>], [<span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.MultiIndex(levels=[[<span class="string">'a'</span>, <span class="string">'b'</span>], [<span class="number">1</span>, <span class="number">2</span>]],</span><br><span class="line">            labels=[[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>多级索引的等级名称</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop.index.names = [<span class="string">'state'</span>, <span class="string">'year'</span>]</span><br><span class="line">pop</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>多级列索引</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多级行列索引</span></span><br><span class="line">index = pd.MultiIndex.from_product([[<span class="number">2013</span>, <span class="number">2014</span>], [<span class="number">1</span>, <span class="number">2</span>]],</span><br><span class="line">            names=[<span class="string">'year'</span>, <span class="string">'visit'</span>])</span><br><span class="line">columns = pd.MultiIndex.from_product([[<span class="string">'Bob'</span>, <span class="string">'Guido'</span>, <span class="string">'Sue'</span>], [<span class="string">'HR'</span>, <span class="string">'Temp'</span>]],</span><br><span class="line">            names=[<span class="string">'subject'</span>, <span class="string">'type'</span>])</span><br><span class="line"></span><br><span class="line">data = np.round(np.random.randn(<span class="number">4</span>, <span class="number">6</span>), <span class="number">1</span>)</span><br><span class="line">data[:, ::<span class="number">2</span>] *= <span class="number">10</span></span><br><span class="line">data += <span class="number">37</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建DataFrame</span></span><br><span class="line">health_data = pd.DataFrame(data, index=index, columns=columns)</span><br><span class="line">health_data</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">health_data[<span class="string">'Guido'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="多级索引的取值与切片"><a href="#多级索引的取值与切片" class="headerlink" title="多级索引的取值与切片"></a>多级索引的取值与切片</h2><ol>
<li>Series多级索引</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop[<span class="string">'California'</span>, <span class="number">2000</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop[<span class="string">'California'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop.loc[<span class="string">'California'</span>:<span class="string">'New York'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop[[<span class="string">'California'</span>, <span class="string">'Texas'</span>]]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>DataFrame多级索引</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">health_data</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">health_data[<span class="string">'Guido'</span>, <span class="string">'HR'</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">health_data.iloc[:<span class="number">2</span>, :<span class="number">2</span>]</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">health_data.loc[:, (<span class="string">'Bob'</span>, <span class="string">'HR'</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="多级索引行列转换"><a href="#多级索引行列转换" class="headerlink" title="多级索引行列转换"></a>多级索引行列转换</h2><ol>
<li>排序</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index = pd.MultiIndex.from_product([[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>], [<span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line">data = pd.Series(np.random.rand(<span class="number">6</span>), index=index)</span><br><span class="line">data.index.names = [<span class="string">'char'</span>, <span class="string">'int'</span>]</span><br><span class="line">data</span><br></pre></td></tr></table></figure>

<p>此时不能切片（无序）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = data.sort_index()</span><br><span class="line">data</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'a'</span>:<span class="string">'b'</span>]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>索引stack与unstack</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop.unstack(level=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop.unstack(level=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>索引的设置与重置</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pop_flat = pop.reset_index(name=<span class="string">'population'</span>)</span><br><span class="line">pop_flat</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pop_flat.set_index([<span class="string">'state'</span>, <span class="string">'year'</span>])</span><br></pre></td></tr></table></figure>

<h2 id="多级索引的数据累计方法"><a href="#多级索引的数据累计方法" class="headerlink" title="多级索引的数据累计方法"></a>多级索引的数据累计方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">health_data</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data_mean = health_data.mean(level=<span class="string">'year'</span>)</span><br><span class="line">data_mean</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_mean.mean(axis=<span class="number">1</span>, level=<span class="string">'type'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="合并数据集：Concat与Append操作"><a href="#合并数据集：Concat与Append操作" class="headerlink" title="合并数据集：Concat与Append操作"></a>合并数据集：Concat与Append操作</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_df</span><span class="params">(cols, ind)</span>:</span></span><br><span class="line">   <span class="string">"""一个简单的DataFrame"""</span></span><br><span class="line">   data = &#123;c: [str(c) + str(i) <span class="keyword">for</span> i <span class="keyword">in</span> ind]</span><br><span class="line">           <span class="keyword">for</span> c <span class="keyword">in</span> cols&#125;</span><br><span class="line">   <span class="keyword">return</span> pd.DataFrame(data, ind)</span><br><span class="line"></span><br><span class="line"><span class="comment"># DataFrame示例</span></span><br><span class="line">make_df(<span class="string">'ABC'</span>, range(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<h2 id="pd-concat方法"><a href="#pd-concat方法" class="headerlink" title="pd.concat方法"></a><code>pd.concat</code>方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pandas 0.18版中的函数签名</span></span><br><span class="line">pd.concat(objs, axis=<span class="number">0</span>, join=<span class="string">'outer'</span>, join_axes=<span class="literal">None</span>, ignore_index=<span class="literal">False</span>,keys=<span class="literal">None</span>, levels=<span class="literal">None</span>, names=<span class="literal">None</span>, verify_integrity=<span class="literal">False</span>,copy=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>简单地合并一维的 Series 或 DataFrame 对象，与 np.concatenate() 合并数组一样</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ser1 = pd.Series([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>], index=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">ser2 = pd.Series([<span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>], index=[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">pd.concat([ser1, ser2])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df1 = make_df(<span class="string">'AB'</span>, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">df2 = make_df(<span class="string">'AB'</span>, [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(df1); print(df2); print(pd.concat([df1, df2]))</span><br></pre></td></tr></table></figure>

<p>默认情况下，DataFrame 的合并都是逐行进行的（默认设置是 axis=0）。与 np.concatenate() 一样，pd.concat 也可以设置合并坐标轴</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df3 = make_df(<span class="string">'AB'</span>, [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">df4 = make_df(<span class="string">'CD'</span>, [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">print(df3); print(df4); print(pd.concat([df3, df4], axis=<span class="number">1</span>))<span class="comment"># axis = 'col(按列合并，按行延长)'</span></span><br></pre></td></tr></table></figure>

<ol>
<li>索引重复</li>
</ol>
<p>np.concatenate 与 pd.concat 最主要的差异之一就是 Pandas 在合并时会保留索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = make_df(<span class="string">'AB'</span>, [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = make_df(<span class="string">'AB'</span>, [<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">y.index = x.index  <span class="comment"># 复制索引</span></span><br><span class="line">print(x); print(y); print(pd.concat([x, y]))</span><br></pre></td></tr></table></figure>

<ul>
<li>捕捉索引重复的错误</li>
</ul>
<p>设置 verify_integrity 参数。将参数设置为 True，合并时若有索引重复就会<br>触发异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    pd.concat([x, y], verify_integrity=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"ValueError:"</span>, e)</span><br></pre></td></tr></table></figure>

<ul>
<li>忽略索引</li>
</ul>
<p>ignore_index</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.concat([x, y], ignore_index=<span class="literal">True</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li>增加多级索引</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.concat([x, y], keys=[<span class="string">'x'</span>, <span class="string">'y'</span>]))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>类似join的合并</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df5 = make_df(<span class="string">'ABC'</span>, [<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">df6 = make_df(<span class="string">'BCD'</span>, [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(df5); print(df6)</span><br><span class="line">print(pd.concat([df5,df6]))</span><br></pre></td></tr></table></figure>


<pre><code>---------------------------------------------------------------------------

NameError                                 Traceback (most recent call last)

&lt;ipython-input-28-4310d251cd1d&gt; in &lt;module&gt;
----&gt; 1 df5 = make_df(&apos;ABC&apos;, [1, 2])
      2 df6 = make_df(&apos;BCD&apos;, [3, 4])
      3 print(df5); print(df6)
      4 print(pd.concat([df5,df6]))


NameError: name &apos;make_df&apos; is not defined</code></pre><p>如果不想让缺失的值被NaN代替。可以用join 和join_axes参数设置合并方式</p>
<p>默认： <code>join = &#39;outer&#39;</code>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.concat([df5, df6], join=<span class="string">'inner'</span>))</span><br></pre></td></tr></table></figure>

<p>另一种合并方式是直接确定结果使用的列名，设置 join_axes 参数，里面是索引对象构成<br>的列表（是列表的列表）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.concat([df5,df6],join_axes = [df5.columns]))</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>append()方法</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(df1);print(df2);print(df1.append(df2))</span><br></pre></td></tr></table></figure>

<ul>
<li>注： pandas的append()不直接更新原有对象的值，而是为合并后的数据创建一个新对象，因此并不高效。</li>
</ul>
<h1 id="合并数据集：-合并与连接"><a href="#合并数据集：-合并与连接" class="headerlink" title="合并数据集： 合并与连接"></a>合并数据集： 合并与连接</h1><h2 id="数据连接"><a href="#数据连接" class="headerlink" title="数据连接"></a>数据连接</h2><ol>
<li>一对一</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'employee'</span>: [<span class="string">'Bob'</span>, <span class="string">'Jake'</span>, <span class="string">'Lisa'</span>, <span class="string">'Sue'</span>],</span><br><span class="line"><span class="string">'group'</span>: [<span class="string">'Accounting'</span>, <span class="string">'Engineering'</span>, <span class="string">'Engineering'</span>, <span class="string">'HR'</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'employee'</span>: [<span class="string">'Lisa'</span>, <span class="string">'Bob'</span>, <span class="string">'Jake'</span>, <span class="string">'Sue'</span>],</span><br><span class="line"><span class="string">'hire_date'</span>: [<span class="number">2004</span>, <span class="number">2008</span>, <span class="number">2012</span>, <span class="number">2014</span>]&#125;)</span><br><span class="line">print(df1); print(df2)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">df3 = pd.merge(df1,df2)</span><br><span class="line">df3</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>多对一</li>
</ol>
<p>在需要连接的两个列中，有一列的值有重复</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df4 = pd.DataFrame(&#123;<span class="string">'group'</span>: [<span class="string">'Accounting'</span>, <span class="string">'Engineering'</span>, <span class="string">'HR'</span>],</span><br><span class="line"><span class="string">'supervisor'</span>: [<span class="string">'Carly'</span>, <span class="string">'Guido'</span>, <span class="string">'Steve'</span>]&#125;)</span><br><span class="line">print(df3); print(df4); print(pd.merge(df3, df4))</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>多对多</li>
</ol>
<p>左右两个输入的同列都包含重复值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df5 = pd.DataFrame(&#123;<span class="string">'group'</span>: [<span class="string">'Accounting'</span>, <span class="string">'Accounting'</span>,</span><br><span class="line">                    <span class="string">'Engineering'</span>, <span class="string">'Engineering'</span>, <span class="string">'HR'</span>, <span class="string">'HR'</span>],</span><br><span class="line"><span class="string">'skills'</span>: [<span class="string">'math'</span>, <span class="string">'spreadsheets'</span>, <span class="string">'coding'</span>, <span class="string">'linux'</span>,</span><br><span class="line">           <span class="string">'spreadsheets'</span>, <span class="string">'organization'</span>]&#125;)</span><br><span class="line">print(df1); print(df5); print(pd.merge(df1, df5))</span><br></pre></td></tr></table></figure>

<h2 id="设置数据合并的键"><a href="#设置数据合并的键" class="headerlink" title="设置数据合并的键"></a>设置数据合并的键</h2><ol>
<li>on参数：将on参数设置为一个列名字符串或者一个包含多列名称的列表</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">print(df1)</span><br><span class="line">print(df2)</span><br><span class="line">print(pd.merge(df1,df2))</span><br><span class="line">print(pd.merge(df1,df2,on = <span class="string">'employee'</span>))</span><br></pre></td></tr></table></figure>

<p>这个参数只能在两个 DataFrame 有共同列名的时候才可以使用。</p>
<ol start="2">
<li>left_on 与right_on参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df3 = pd.DataFrame(&#123;<span class="string">'name'</span>: [<span class="string">'Bob'</span>, <span class="string">'Jake'</span>, <span class="string">'Lisa'</span>, <span class="string">'Sue'</span>],</span><br><span class="line"><span class="string">'salary'</span>: [<span class="number">70000</span>, <span class="number">80000</span>, <span class="number">120000</span>, <span class="number">90000</span>]&#125;)</span><br><span class="line">print(df1);</span><br><span class="line">print(df3)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.merge(df1,df3,left_on = <span class="string">'employee'</span>,right_on = <span class="string">'name'</span>))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(df1, df3, left_on=<span class="string">"employee"</span>, right_on=<span class="string">"name"</span>).drop(<span class="string">'name'</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>left_index 与 right_index 参数</li>
</ol>
<p>合并索引</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df1a = df1.set_index(<span class="string">'employee'</span>)</span><br><span class="line">df2a = df2.set_index(<span class="string">'employee'</span>)</span><br><span class="line">print(df1a)</span><br><span class="line">print(df2a)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.merge(df1a,df2a,left_index = <span class="literal">True</span>, right_index = <span class="literal">True</span>))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1a.join(df2a)</span><br></pre></td></tr></table></figure>

<p>索引与列混合使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.merge(df1a, df3, left_index=<span class="literal">True</span>, right_on=<span class="string">'name'</span>))</span><br></pre></td></tr></table></figure>

<h2 id="设置数据连接的集合操作规则"><a href="#设置数据连接的集合操作规则" class="headerlink" title="设置数据连接的集合操作规则"></a>设置数据连接的集合操作规则</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">df6 = pd.DataFrame(&#123;<span class="string">'name'</span>: [<span class="string">'Peter'</span>, <span class="string">'Paul'</span>, <span class="string">'Mary'</span>],</span><br><span class="line">                    <span class="string">'food'</span>: [<span class="string">'fish'</span>, <span class="string">'beans'</span>, <span class="string">'bread'</span>]&#125;,</span><br><span class="line">                    columns=[<span class="string">'name'</span>, <span class="string">'food'</span>])</span><br><span class="line">df7 = pd.DataFrame(&#123;<span class="string">'name'</span>: [<span class="string">'Mary'</span>, <span class="string">'Joseph'</span>],</span><br><span class="line">                    <span class="string">'drink'</span>: [<span class="string">'wine'</span>, <span class="string">'beer'</span>]&#125;,</span><br><span class="line">                    columns=[<span class="string">'name'</span>, <span class="string">'drink'</span>])</span><br><span class="line">print(df6);print(); print(df7); print();print(pd.merge(df6, df7))</span><br></pre></td></tr></table></figure>

<p>默认情况下，结果中只会包含两个输入集合的交集，这种连接方式被称为内连接（inner join）</p>
<p>改为外连接：how = ‘outer’</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.merge(df6,df7,how = <span class="string">'outer'</span>))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.merge(df6, df7, how=<span class="string">'left'</span>))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(pd.merge(df6, df7, how=<span class="string">'right'</span>))</span><br></pre></td></tr></table></figure>

<p>现在输出的行中只包含左边输入列的值。如果用 how=’right’ 的话，输出的行则只包含右<br>边输入列的值。</p>
<h2 id="重复列名：suffixes"><a href="#重复列名：suffixes" class="headerlink" title="重复列名：suffixes"></a>重复列名：suffixes</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df8 = pd.DataFrame(&#123;<span class="string">'name'</span>: [<span class="string">'Bob'</span>, <span class="string">'Jake'</span>, <span class="string">'Lisa'</span>, <span class="string">'Sue'</span>],</span><br><span class="line">                    <span class="string">'rank'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line">df9 = pd.DataFrame(&#123;<span class="string">'name'</span>: [<span class="string">'Bob'</span>, <span class="string">'Jake'</span>, <span class="string">'Lisa'</span>, <span class="string">'Sue'</span>],</span><br><span class="line">                    <span class="string">'rank'</span>: [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>]&#125;)</span><br><span class="line">print(df8); print(df9); print(pd.merge(df8, df9, on=<span class="string">"name"</span>))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过suffixes参数自定义后缀名</span></span><br><span class="line">print(df8); print(df9);</span><br><span class="line">print(pd.merge(df8, df9, on=<span class="string">"name"</span>, suffixes=[<span class="string">"_L"</span>, <span class="string">"_R"</span>]))</span><br></pre></td></tr></table></figure>

<h1 id="分组与累计"><a href="#分组与累计" class="headerlink" title="分组与累计"></a>分组与累计</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">42</span>)</span><br><span class="line">ser = pd.Series(rng.rand(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser</span><br></pre></td></tr></table></figure>




<pre><code>0    0.374540
1    0.950714
2    0.731994
3    0.598658
4    0.156019
dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ser.sum()</span><br></pre></td></tr></table></figure>




<pre><code>2.811925491708157</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DataFrame</span></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'A'</span>:rng.rand(<span class="number">5</span>),<span class="string">'B'</span>:rng.rand(<span class="number">5</span>)&#125;)</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0.155995</td>
      <td>0.020584</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.058084</td>
      <td>0.969910</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.866176</td>
      <td>0.832443</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.601115</td>
      <td>0.212339</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.708073</td>
      <td>0.181825</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.mean()</span><br></pre></td></tr></table></figure>




<pre><code>A    0.477888
B    0.443420
dtype: float64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.mean(axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>




<pre><code>0    0.088290
1    0.513997
2    0.849309
3    0.406727
4    0.444949
dtype: float64</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">指标| 描述</span><br><span class="line">-|-</span><br><span class="line">count() |计数项</span><br><span class="line">first()、 last() |第一项与最后一项</span><br><span class="line">mean()、 median() |均值与中位数</span><br><span class="line">min()、 max() |最小值与最大值</span><br><span class="line">std()、 var() |标准差与方差</span><br><span class="line">mad() |均值绝对偏差（mean absolute deviation）</span><br><span class="line">prod() |所有项乘积</span><br><span class="line">sum() |所有项求和</span><br><span class="line"></span><br><span class="line">## GroupBy：分隔、应用、组合</span><br><span class="line"></span><br><span class="line">1. 分隔、应用和组合</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">df &#x3D; pd.DataFrame(&#123;&#39;key&#39;: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;],</span><br><span class="line">                    &#39;data&#39;: range(6)&#125;, columns&#x3D;[&#39;key&#39;, &#39;data&#39;])</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>data</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>A</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>B</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>C</td>
      <td>2</td>
    </tr>
    <tr>
      <th>3</th>
      <td>A</td>
      <td>3</td>
    </tr>
    <tr>
      <th>4</th>
      <td>B</td>
      <td>4</td>
    </tr>
    <tr>
      <th>5</th>
      <td>C</td>
      <td>5</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">'key'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&lt;pandas.core.groupby.groupby.DataFrameGroupBy object at 0x0000027627AED1D0&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">'key'</span>).sum()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>data</th>
    </tr>
    <tr>
      <th>key</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>3</td>
    </tr>
    <tr>
      <th>B</th>
      <td>5</td>
    </tr>
    <tr>
      <th>C</th>
      <td>7</td>
    </tr>
  </tbody>
</table>
</div>



<p>可以用 Pandas 或 NumPy 的任意一种累计函数，也<br>可以用任意有效的 DataFrame 对象。</p>
<ol start="2">
<li>GroupBy对象</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">planets = sns.load_dataset(<span class="string">'planets'</span>)</span><br><span class="line">planets.shape</span><br></pre></td></tr></table></figure>




<pre><code>(1035, 6)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">planets.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>method</th>
      <th>number</th>
      <th>orbital_period</th>
      <th>mass</th>
      <th>distance</th>
      <th>year</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Radial Velocity</td>
      <td>1</td>
      <td>269.300</td>
      <td>7.10</td>
      <td>77.40</td>
      <td>2006</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Radial Velocity</td>
      <td>1</td>
      <td>874.774</td>
      <td>2.21</td>
      <td>56.95</td>
      <td>2008</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Radial Velocity</td>
      <td>1</td>
      <td>763.000</td>
      <td>2.60</td>
      <td>19.84</td>
      <td>2011</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Radial Velocity</td>
      <td>1</td>
      <td>326.030</td>
      <td>19.40</td>
      <td>110.62</td>
      <td>2007</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Radial Velocity</td>
      <td>1</td>
      <td>516.220</td>
      <td>10.50</td>
      <td>119.47</td>
      <td>2009</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">planets.dropna().describe()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>number</th>
      <th>orbital_period</th>
      <th>mass</th>
      <th>distance</th>
      <th>year</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>498.00000</td>
      <td>498.000000</td>
      <td>498.000000</td>
      <td>498.000000</td>
      <td>498.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>1.73494</td>
      <td>835.778671</td>
      <td>2.509320</td>
      <td>52.068213</td>
      <td>2007.377510</td>
    </tr>
    <tr>
      <th>std</th>
      <td>1.17572</td>
      <td>1469.128259</td>
      <td>3.636274</td>
      <td>46.596041</td>
      <td>4.167284</td>
    </tr>
    <tr>
      <th>min</th>
      <td>1.00000</td>
      <td>1.328300</td>
      <td>0.003600</td>
      <td>1.350000</td>
      <td>1989.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>1.00000</td>
      <td>38.272250</td>
      <td>0.212500</td>
      <td>24.497500</td>
      <td>2005.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>1.00000</td>
      <td>357.000000</td>
      <td>1.245000</td>
      <td>39.940000</td>
      <td>2009.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>2.00000</td>
      <td>999.600000</td>
      <td>2.867500</td>
      <td>59.332500</td>
      <td>2011.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>6.00000</td>
      <td>17337.500000</td>
      <td>25.000000</td>
      <td>354.000000</td>
      <td>2014.000000</td>
    </tr>
  </tbody>
</table>
</div>



<ul>
<li>按列取值</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">planets.groupby(<span class="string">'method'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&lt;pandas.core.groupby.groupby.DataFrameGroupBy object at 0x0000027629029EF0&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">planets.groupby(<span class="string">'method'</span>)[<span class="string">'orbital_period'</span>]</span><br></pre></td></tr></table></figure>




<pre><code>&lt;pandas.core.groupby.groupby.SeriesGroupBy object at 0x000002762A05A198&gt;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">planets.groupby(<span class="string">'method'</span>)[<span class="string">'orbital_period'</span>].median()</span><br></pre></td></tr></table></figure>




<pre><code>method
Astrometry                         631.180000
Eclipse Timing Variations         4343.500000
Imaging                          27500.000000
Microlensing                      3300.000000
Orbital Brightness Modulation        0.342887
Pulsar Timing                       66.541900
Pulsation Timing Variations       1170.000000
Radial Velocity                    360.200000
Transit                              5.714932
Transit Timing Variations           57.011000
Name: orbital_period, dtype: float64</code></pre><ul>
<li><p>按组迭代</p>
<p>GroupBy 对象支持直接按组进行迭代，返回的每一组都是 Series 或 DataFrame：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (method,group) <span class="keyword">in</span> planets.groupby(<span class="string">'method'</span>):</span><br><span class="line">    print(<span class="string">"&#123;0:30s&#125; shape = &#123;1&#125;"</span>.format(method, group.shape))</span><br></pre></td></tr></table></figure>

<pre><code>Astrometry                     shape = (2, 6)
Eclipse Timing Variations      shape = (9, 6)
Imaging                        shape = (38, 6)
Microlensing                   shape = (23, 6)
Orbital Brightness Modulation  shape = (3, 6)
Pulsar Timing                  shape = (5, 6)
Pulsation Timing Variations    shape = (1, 6)
Radial Velocity                shape = (553, 6)
Transit                        shape = (397, 6)
Transit Timing Variations      shape = (4, 6)</code></pre><ul>
<li>调用方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">planets.groupby(<span class="string">'method'</span>)[<span class="string">"year"</span>].describe().unstack()</span><br></pre></td></tr></table></figure>




<pre><code>       method                       
count  Astrometry                          2.000000
       Eclipse Timing Variations           9.000000
       Imaging                            38.000000
       Microlensing                       23.000000
       Orbital Brightness Modulation       3.000000
       Pulsar Timing                       5.000000
       Pulsation Timing Variations         1.000000
       Radial Velocity                   553.000000
       Transit                           397.000000
       Transit Timing Variations           4.000000
mean   Astrometry                       2011.500000
       Eclipse Timing Variations        2010.000000
       Imaging                          2009.131579
       Microlensing                     2009.782609
       Orbital Brightness Modulation    2011.666667
       Pulsar Timing                    1998.400000
       Pulsation Timing Variations      2007.000000
       Radial Velocity                  2007.518987
       Transit                          2011.236776
       Transit Timing Variations        2012.500000
std    Astrometry                          2.121320
       Eclipse Timing Variations           1.414214
       Imaging                             2.781901
       Microlensing                        2.859697
       Orbital Brightness Modulation       1.154701
       Pulsar Timing                       8.384510
       Pulsation Timing Variations              NaN
       Radial Velocity                     4.249052
       Transit                             2.077867
       Transit Timing Variations           1.290994
                                           ...     
50%    Astrometry                       2011.500000
       Eclipse Timing Variations        2010.000000
       Imaging                          2009.000000
       Microlensing                     2010.000000
       Orbital Brightness Modulation    2011.000000
       Pulsar Timing                    1994.000000
       Pulsation Timing Variations      2007.000000
       Radial Velocity                  2009.000000
       Transit                          2012.000000
       Transit Timing Variations        2012.500000
75%    Astrometry                       2012.250000
       Eclipse Timing Variations        2011.000000
       Imaging                          2011.000000
       Microlensing                     2012.000000
       Orbital Brightness Modulation    2012.000000
       Pulsar Timing                    2003.000000
       Pulsation Timing Variations      2007.000000
       Radial Velocity                  2011.000000
       Transit                          2013.000000
       Transit Timing Variations        2013.250000
max    Astrometry                       2013.000000
       Eclipse Timing Variations        2012.000000
       Imaging                          2013.000000
       Microlensing                     2013.000000
       Orbital Brightness Modulation    2013.000000
       Pulsar Timing                    2011.000000
       Pulsation Timing Variations      2007.000000
       Radial Velocity                  2014.000000
       Transit                          2014.000000
       Transit Timing Variations        2014.000000
Length: 80, dtype: float64</code></pre><ol start="3">
<li>累计、过滤、转换和应用</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rng = np.random.RandomState(<span class="number">0</span>)</span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'key'</span> : [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>],</span><br><span class="line">                  <span class="string">'data1'</span>: range(<span class="number">6</span>),</span><br><span class="line">                  <span class="string">'data2'</span>: rng.randint(<span class="number">0</span>,<span class="number">10</span>,<span class="number">6</span>)&#125;,</span><br><span class="line">                  columns = [<span class="string">'key'</span>,<span class="string">'data1'</span>,<span class="string">'data2'</span>])</span><br><span class="line">df</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>key</th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>A</td>
      <td>0</td>
      <td>5</td>
    </tr>
    <tr>
      <th>1</th>
      <td>B</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>C</td>
      <td>2</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>A</td>
      <td>3</td>
      <td>3</td>
    </tr>
    <tr>
      <th>4</th>
      <td>B</td>
      <td>4</td>
      <td>7</td>
    </tr>
    <tr>
      <th>5</th>
      <td>C</td>
      <td>5</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>



<ul>
<li>累计</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">'key'</span>).aggregate([<span class="string">'min'</span>,np.median,max])</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead tr th {
    text-align: left;
}

.dataframe thead tr:last-of-type th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="3" halign="left">data1</th>
      <th colspan="3" halign="left">data2</th>
    </tr>
    <tr>
      <th></th>
      <th>min</th>
      <th>median</th>
      <th>max</th>
      <th>min</th>
      <th>median</th>
      <th>max</th>
    </tr>
    <tr>
      <th>key</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>0</td>
      <td>1.5</td>
      <td>3</td>
      <td>3</td>
      <td>4.0</td>
      <td>5</td>
    </tr>
    <tr>
      <th>B</th>
      <td>1</td>
      <td>2.5</td>
      <td>4</td>
      <td>0</td>
      <td>3.5</td>
      <td>7</td>
    </tr>
    <tr>
      <th>C</th>
      <td>2</td>
      <td>3.5</td>
      <td>5</td>
      <td>3</td>
      <td>6.0</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">'key'</span>).aggregate(&#123;<span class="string">'data1'</span>:<span class="string">'min'</span>,<span class="string">'data2'</span>:max&#125;)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>data1</th>
      <th>data2</th>
    </tr>
    <tr>
      <th>key</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>A</th>
      <td>0</td>
      <td>5</td>
    </tr>
    <tr>
      <th>B</th>
      <td>1</td>
      <td>7</td>
    </tr>
    <tr>
      <th>C</th>
      <td>2</td>
      <td>9</td>
    </tr>
  </tbody>
</table>
</div>



<ul>
<li>过滤</li>
</ul>
<p>过滤操作可以让你按照分组的属性丢弃若干数据。例如，我们可能只需要保留标<br>准差超过某个阈值的组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter_func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x[<span class="string">'data2'</span>].std()&gt;<span class="number">4</span></span><br><span class="line">print(df); print(df.groupby(<span class="string">'key'</span>).std());<span class="comment">#标准差</span></span><br><span class="line">print(df.groupby(<span class="string">'key'</span>).filter(filter_func))</span><br></pre></td></tr></table></figure>

<pre><code>  key  data1  data2
0   A      0      5
1   B      1      0
2   C      2      3
3   A      3      3
4   B      4      7
5   C      5      9
       data1     data2
key                   
A    2.12132  1.414214
B    2.12132  4.949747
C    2.12132  4.242641
  key  data1  data2
1   B      1      0
2   C      2      3
4   B      4      7
5   C      5      9</code></pre><ul>
<li>转换</li>
</ul>
<p>累计操作返回的是对组内全量数据缩减过的结果，而转换操作会返回一个新的全量数据。数据经过转换之后，其形状与原来的输入数据是一样的。常见的例子就是将每一组的样本数据减去各组的均值，实现数据标准化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.groupby(<span class="string">'key'</span>).transform(<span class="keyword">lambda</span> x: x - x.mean())</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>-1.5</td>
      <td>1.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>-1.5</td>
      <td>-3.5</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-1.5</td>
      <td>-3.0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1.5</td>
      <td>-1.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1.5</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>5</th>
      <td>1.5</td>
      <td>3.0</td>
    </tr>
  </tbody>
</table>
</div>



<ul>
<li>apply（） 方法</li>
</ul>
<p>apply() 方法让你可以在每个组上应用任意方法。这个函数输入一个<br>DataFrame，返回一个 Pandas 对象（DataFrame 或 Series）或一个标量（scalar，单个数<br>值）。组合操作会适应返回结果类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">norm_by_data2</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="comment"># x是一个分组数据的DataFrame</span></span><br><span class="line">    x[<span class="string">'data1'</span>] /= x[<span class="string">'data2'</span>].sum()</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">print(df); print(df.groupby(<span class="string">'key'</span>).apply(norm_by_data2))</span><br></pre></td></tr></table></figure>

<pre><code>  key  data1  data2
0   A      0      5
1   B      1      0
2   C      2      3
3   A      3      3
4   B      4      7
5   C      5      9
  key     data1  data2
0   A  0.000000      5
1   B  0.142857      0
2   C  0.166667      3
3   A  0.375000      3
4   B  0.571429      7
5   C  0.416667      9</code></pre><ol start="4">
<li>设置分隔的键</li>
</ol>
<ul>
<li>将列表、 数组、 Series 或索引作为分组键 </li>
</ul>
<p>分组键可以是长度与 DataFrame 匹配的任意Series 或列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">L = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>]</span><br><span class="line">print(df);print(df.groupby(L).sum())</span><br></pre></td></tr></table></figure>

<pre><code>  key  data1  data2
0   A      0      5
1   B      1      0
2   C      2      3
3   A      3      3
4   B      4      7
5   C      5      9
   data1  data2
0      7     17
1      4      3
2      4      7</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(df); print(df.groupby(df[<span class="string">'key'</span>]).sum())</span><br></pre></td></tr></table></figure>

<pre><code>  key  data1  data2
0   A      0      5
1   B      1      0
2   C      2      3
3   A      3      3
4   B      4      7
5   C      5      9
     data1  data2
key              
A        3      8
B        5      7
C        7     12</code></pre><ul>
<li>用字典或 Series 将索引映射到分组名称。另一种方法是提供一个字典，将索引映射到分组键：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">df2 = df.set_index(<span class="string">'key'</span>)</span><br><span class="line">mapping = &#123;<span class="string">'A'</span>: <span class="string">'vowel'</span>, <span class="string">'B'</span>: <span class="string">'consonant'</span>, <span class="string">'C'</span>: <span class="string">'consonant'</span>&#125;</span><br><span class="line">print(df2); print(df2.groupby(mapping).sum())</span><br></pre></td></tr></table></figure>

<pre><code>     data1  data2
key              
A        0      5
B        1      0
C        2      3
A        3      3
B        4      7
C        5      9
           data1  data2
consonant     12     19
vowel          3      8</code></pre><ul>
<li>任意 Python 函数。与前面的字典映射类似，你可以将任意 Python 函数传入 groupby，<br>函数映射到索引，然后新的分组输出：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(df2); print(df2.groupby(str.lower).mean())</span><br></pre></td></tr></table></figure>

<pre><code>     data1  data2
key              
A        0      5
B        1      0
C        2      3
A        3      3
B        4      7
C        5      9
   data1  data2
a    1.5    4.0
b    2.5    3.5
c    3.5    6.0</code></pre><ul>
<li>多个有效键构成的列表。此外，任意之前有效的键都可以组合起来进行分组，从而返回一个多级索引的分组结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df2.groupby([str.lower, mapping]).mean()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>data1</th>
      <th>data2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <th>vowel</th>
      <td>1.5</td>
      <td>4.0</td>
    </tr>
    <tr>
      <th>b</th>
      <th>consonant</th>
      <td>2.5</td>
      <td>3.5</td>
    </tr>
    <tr>
      <th>c</th>
      <th>consonant</th>
      <td>3.5</td>
      <td>6.0</td>
    </tr>
  </tbody>
</table>
</div>



<h1 id="数据透视表"><a href="#数据透视表" class="headerlink" title="数据透视表"></a>数据透视表</h1><p>数据透视表更像是一种多维的 GroupBy 累计操作。也就<br>是说，虽然你也可以分割 - 应用 - 组合，但是分割与组合不是发生在一维索引上，而是在<br>二维网格上（行列同时分组）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">titanic = sns.load_dataset(<span class="string">'titanic'</span>)</span><br><span class="line">titanic.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>survived</th>
      <th>pclass</th>
      <th>sex</th>
      <th>age</th>
      <th>sibsp</th>
      <th>parch</th>
      <th>fare</th>
      <th>embarked</th>
      <th>class</th>
      <th>who</th>
      <th>adult_male</th>
      <th>deck</th>
      <th>embark_town</th>
      <th>alive</th>
      <th>alone</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>3</td>
      <td>male</td>
      <td>22.0</td>
      <td>1</td>
      <td>0</td>
      <td>7.2500</td>
      <td>S</td>
      <td>Third</td>
      <td>man</td>
      <td>True</td>
      <td>NaN</td>
      <td>Southampton</td>
      <td>no</td>
      <td>False</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>1</td>
      <td>female</td>
      <td>38.0</td>
      <td>1</td>
      <td>0</td>
      <td>71.2833</td>
      <td>C</td>
      <td>First</td>
      <td>woman</td>
      <td>False</td>
      <td>C</td>
      <td>Cherbourg</td>
      <td>yes</td>
      <td>False</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>3</td>
      <td>female</td>
      <td>26.0</td>
      <td>0</td>
      <td>0</td>
      <td>7.9250</td>
      <td>S</td>
      <td>Third</td>
      <td>woman</td>
      <td>False</td>
      <td>NaN</td>
      <td>Southampton</td>
      <td>yes</td>
      <td>True</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>1</td>
      <td>female</td>
      <td>35.0</td>
      <td>1</td>
      <td>0</td>
      <td>53.1000</td>
      <td>S</td>
      <td>First</td>
      <td>woman</td>
      <td>False</td>
      <td>C</td>
      <td>Southampton</td>
      <td>yes</td>
      <td>False</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>3</td>
      <td>male</td>
      <td>35.0</td>
      <td>0</td>
      <td>0</td>
      <td>8.0500</td>
      <td>S</td>
      <td>Third</td>
      <td>man</td>
      <td>True</td>
      <td>NaN</td>
      <td>Southampton</td>
      <td>no</td>
      <td>True</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titanic.groupby(<span class="string">'sex'</span>)[[<span class="string">'survived'</span>]].mean()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>survived</th>
    </tr>
    <tr>
      <th>sex</th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>female</th>
      <td>0.742038</td>
    </tr>
    <tr>
      <th>male</th>
      <td>0.188908</td>
    </tr>
  </tbody>
</table>
</div>



<h1 id="自制数据透视表"><a href="#自制数据透视表" class="headerlink" title="自制数据透视表"></a>自制数据透视表</h1><p>将船舱等级（’class’）与<br>性别（’sex’） 分组，然后选择生还状态（’survived’）列， 应用均值（’mean’）累计函<br>数，再将各组结果组合，最后通过行索引转列索引操作将最里层的行索引转换成列索引，<br>形成二维数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titanic.groupby([<span class="string">'sex'</span>, <span class="string">'class'</span>])[<span class="string">'survived'</span>].aggregate(<span class="string">'mean'</span>).unstack()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>class</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
    </tr>
    <tr>
      <th>sex</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>female</th>
      <td>0.968085</td>
      <td>0.921053</td>
      <td>0.500000</td>
    </tr>
    <tr>
      <th>male</th>
      <td>0.368852</td>
      <td>0.157407</td>
      <td>0.135447</td>
    </tr>
  </tbody>
</table>
</div>



<h2 id="数据透视表语法"><a href="#数据透视表语法" class="headerlink" title="数据透视表语法"></a>数据透视表语法</h2><p>用 DataFrame 的 pivot_table 实现的效果等同于上一节的管道命令的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titanic.pivot_table(<span class="string">'survived'</span>, index = <span class="string">'sex'</span>, columns = <span class="string">'class'</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>class</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
    </tr>
    <tr>
      <th>sex</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>female</th>
      <td>0.968085</td>
      <td>0.921053</td>
      <td>0.500000</td>
    </tr>
    <tr>
      <th>male</th>
      <td>0.368852</td>
      <td>0.157407</td>
      <td>0.135447</td>
    </tr>
  </tbody>
</table>
</div>



<ol>
<li>多级数据透视表</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age = pd.cut(titanic[<span class="string">'age'</span>],[<span class="number">0</span>,<span class="number">18</span>,<span class="number">80</span>])</span><br><span class="line">titanic.pivot_table(<span class="string">'survived'</span>,[<span class="string">'sex'</span>,age],<span class="string">'class'</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>class</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
    </tr>
    <tr>
      <th>sex</th>
      <th>age</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">female</th>
      <th>(0, 18]</th>
      <td>0.909091</td>
      <td>1.000000</td>
      <td>0.511628</td>
    </tr>
    <tr>
      <th>(18, 80]</th>
      <td>0.972973</td>
      <td>0.900000</td>
      <td>0.423729</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">male</th>
      <th>(0, 18]</th>
      <td>0.800000</td>
      <td>0.600000</td>
      <td>0.215686</td>
    </tr>
    <tr>
      <th>(18, 80]</th>
      <td>0.375000</td>
      <td>0.071429</td>
      <td>0.133663</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fare = pd.qcut(titanic[<span class="string">'fare'</span>], <span class="number">2</span>)</span><br><span class="line">titanic.pivot_table(<span class="string">'survived'</span>, [<span class="string">'sex'</span>, age], [fare, <span class="string">'class'</span>])</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead tr th {
    text-align: left;
}

.dataframe thead tr:last-of-type th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th>fare</th>
      <th colspan="3" halign="left">(-0.001, 14.454]</th>
      <th colspan="3" halign="left">(14.454, 512.329]</th>
    </tr>
    <tr>
      <th></th>
      <th>class</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
    </tr>
    <tr>
      <th>sex</th>
      <th>age</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">female</th>
      <th>(0, 18]</th>
      <td>NaN</td>
      <td>1.000000</td>
      <td>0.714286</td>
      <td>0.909091</td>
      <td>1.000000</td>
      <td>0.318182</td>
    </tr>
    <tr>
      <th>(18, 80]</th>
      <td>NaN</td>
      <td>0.880000</td>
      <td>0.444444</td>
      <td>0.972973</td>
      <td>0.914286</td>
      <td>0.391304</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">male</th>
      <th>(0, 18]</th>
      <td>NaN</td>
      <td>0.000000</td>
      <td>0.260870</td>
      <td>0.800000</td>
      <td>0.818182</td>
      <td>0.178571</td>
    </tr>
    <tr>
      <th>(18, 80]</th>
      <td>0.0</td>
      <td>0.098039</td>
      <td>0.125000</td>
      <td>0.391304</td>
      <td>0.030303</td>
      <td>0.192308</td>
    </tr>
  </tbody>
</table>
</div>



<ol start="2">
<li>其他数据透视表选项</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pandas 0.18版的函数签名</span></span><br><span class="line">DataFrame.pivot_table(data, values=<span class="literal">None</span>, index=<span class="literal">None</span>, columns=<span class="literal">None</span>,</span><br><span class="line">aggfunc=<span class="string">'mean'</span>, fill_value=<span class="literal">None</span>, margins=<span class="literal">False</span>,</span><br><span class="line">dropna=<span class="literal">True</span>, margins_name=<span class="string">'All'</span>)</span><br></pre></td></tr></table></figure>

<p>aggfunc 参数用于设置累计函数类型，默认值是均值（mean）。与 GroupBy 的用法一样，累计函数可以用一些常见的字符串（’sum’、 ‘mean’、 ‘count’、 ‘min’、 ‘max’ 等）表示，也可以用标准的累计函数（np.sum()、 min()、 sum() 等）表示。另外，还可以通过字典为不同的列指定不同的累计函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">titanic.pivot_table(index=<span class="string">'sex'</span>, columns=<span class="string">'class'</span>,</span><br><span class="line">aggfunc=&#123;<span class="string">'survived'</span>:sum, <span class="string">'fare'</span>:<span class="string">'mean'</span>&#125;)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead tr th {
    text-align: left;
}

.dataframe thead tr:last-of-type th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr>
      <th></th>
      <th colspan="3" halign="left">fare</th>
      <th colspan="3" halign="left">survived</th>
    </tr>
    <tr>
      <th>class</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
    </tr>
    <tr>
      <th>sex</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>female</th>
      <td>106.125798</td>
      <td>21.970121</td>
      <td>16.118810</td>
      <td>91</td>
      <td>70</td>
      <td>72</td>
    </tr>
    <tr>
      <th>male</th>
      <td>67.226127</td>
      <td>19.741782</td>
      <td>12.661633</td>
      <td>45</td>
      <td>17</td>
      <td>47</td>
    </tr>
  </tbody>
</table>
</div>



<p>当需要计算每一组的总数时，可以通过 margins 参数来设置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">titanic.pivot_table(<span class="string">'survived'</span>, index=<span class="string">'sex'</span>, columns=<span class="string">'class'</span>, margins=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th>class</th>
      <th>First</th>
      <th>Second</th>
      <th>Third</th>
      <th>All</th>
    </tr>
    <tr>
      <th>sex</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>female</th>
      <td>0.968085</td>
      <td>0.921053</td>
      <td>0.500000</td>
      <td>0.742038</td>
    </tr>
    <tr>
      <th>male</th>
      <td>0.368852</td>
      <td>0.157407</td>
      <td>0.135447</td>
      <td>0.188908</td>
    </tr>
    <tr>
      <th>All</th>
      <td>0.629630</td>
      <td>0.472826</td>
      <td>0.242363</td>
      <td>0.383838</td>
    </tr>
  </tbody>
</table>
</div>



<h1 id="向量化字符串操作"><a href="#向量化字符串操作" class="headerlink" title="向量化字符串操作"></a>向量化字符串操作</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x = np.array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>])</span><br><span class="line">x * <span class="number">2</span></span><br></pre></td></tr></table></figure>




<pre><code>array([ 4,  6, 10, 14, 22, 26])</code></pre><p>由于 NumPy 并没有为字符串数组提供简单的接口，因此需要<br>通过繁琐的 for 循环来解决问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="string">'peter'</span>, <span class="string">'Paul'</span>, <span class="string">'MARY'</span>, <span class="string">'gUIDO'</span>]</span><br><span class="line">[s.capitalize() <span class="keyword">for</span> s <span class="keyword">in</span> data]</span><br></pre></td></tr></table></figure>




<pre><code>[&apos;Peter&apos;, &apos;Paul&apos;, &apos;Mary&apos;, &apos;Guido&apos;]</code></pre><p>这种处理在遇到缺失值时会失效</p>
<p>Pandas 为包含字符串的 Series 和 Index 对象提供的 str 属性堪称两全其美的方法，它既<br>可以满足向量化字符串操作的需求，又可以正确地处理缺失值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">names = pd.Series(data)</span><br><span class="line">names</span><br></pre></td></tr></table></figure>




<pre><code>0    peter
1     Paul
2     MARY
3    gUIDO
dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">names.str.capitalize()</span><br></pre></td></tr></table></figure>




<pre><code>0    Peter
1     Paul
2     Mary
3    Guido
dtype: object</code></pre><h2 id="字符串方法列表"><a href="#字符串方法列表" class="headerlink" title="字符串方法列表"></a>字符串方法列表</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">monte = pd.Series([<span class="string">'Graham Chapman'</span>, <span class="string">'John Cleese'</span>, <span class="string">'Terry Gilliam'</span>,</span><br><span class="line"><span class="string">'Eric Idle'</span>, <span class="string">'Terry Jones'</span>, <span class="string">'Michael Palin'</span>])</span><br></pre></td></tr></table></figure>

<ol>
<li>与python相似</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">len() lower() translate() islower()  </span><br><span class="line">ljust() upper() startswith() isupper()  </span><br><span class="line">rjust() find() endswith() isnumeric()  </span><br><span class="line">center() rfind() isalnum() isdecimal()  </span><br><span class="line">zfill() index() isalpha() split()  </span><br><span class="line">strip() rindex() isdigit() rsplit()  </span><br><span class="line">rstrip() capitalize() isspace() partition()  </span><br><span class="line">lstrip() swapcase() istitle() rpartition()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>正则化表达式</p>
</li>
<li><p>其他字符串方法</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>get()</td>
<td>获取元素索引位置上的值，索引从 0 开始</td>
</tr>
<tr>
<td>slice()</td>
<td>对元素进行切片取值</td>
</tr>
<tr>
<td>slice_replace()</td>
<td>对元素进行切片替换</td>
</tr>
<tr>
<td>cat()</td>
<td></td>
</tr>
<tr>
<td>repeat()</td>
<td>重复元素</td>
</tr>
<tr>
<td>normalize()</td>
<td>将字符串转换为 Unicode 规范形式</td>
</tr>
<tr>
<td>pad()</td>
<td>在字符串的左边、右边或两边增加空格</td>
</tr>
<tr>
<td>wrap()</td>
<td>将字符串按照指定的宽度换行</td>
</tr>
<tr>
<td>join()</td>
<td>用分隔符连接 Series 的每个元素</td>
</tr>
<tr>
<td>get_dummies()</td>
<td>按照分隔符提取每个元素的 dummy 变量，转换为独热（one-hot）编码的 DataFrame</td>
</tr>
</tbody></table>
<ul>
<li>以下两语句效果相同</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monte.str.slice(<span class="number">0</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>




<pre><code>0    Gra
1    Joh
2    Ter
3    Eri
4    Ter
5    Mic
dtype: object</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">monte.str[<span class="number">0</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>




<pre><code>0    Gra
1    Joh
2    Ter
3    Eri
4    Ter
5    Mic
dtype: object</code></pre><p>当你的数据有一列<br>包含了若干已被编码的指标（coded indicator）时，<code>get_dummies()</code>方法就能派上用场了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">full_monte = pd.DataFrame(&#123;<span class="string">'name'</span>: monte,</span><br><span class="line">    <span class="string">'info'</span>: [<span class="string">'B|C|D'</span>, <span class="string">'B|D'</span>, <span class="string">'A|C'</span>, <span class="string">'B|D'</span>, <span class="string">'B|C'</span>,</span><br><span class="line">    <span class="string">'B|C|D'</span>]&#125;)</span><br><span class="line">full_monte</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>name</th>
      <th>info</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Graham Chapman</td>
      <td>B|C|D</td>
    </tr>
    <tr>
      <th>1</th>
      <td>John Cleese</td>
      <td>B|D</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Terry Gilliam</td>
      <td>A|C</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Eric Idle</td>
      <td>B|D</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Terry Jones</td>
      <td>B|C</td>
    </tr>
    <tr>
      <th>5</th>
      <td>Michael Palin</td>
      <td>B|C|D</td>
    </tr>
  </tbody>
</table>
</div>




<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">full_monte[<span class="string">'info'</span>].str.get_dummies(<span class="string">'|'</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>A</th>
      <th>B</th>
      <th>C</th>
      <th>D</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



<h1 id="处理时间序列"><a href="#处理时间序列" class="headerlink" title="处理时间序列"></a>处理时间序列</h1><ul>
<li>时间戳： 表示某个具体时间点</li>
<li>时间间隔与周期</li>
<li>时间增量或持续时间</li>
</ul>
<h2 id="python的日期与时间"><a href="#python的日期与时间" class="headerlink" title="python的日期与时间"></a>python的日期与时间</h2><ol>
<li>datetime 与dateutil</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建日期</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line">datetime(year=<span class="number">2015</span>, month=<span class="number">7</span>, day=<span class="number">4</span>)</span><br></pre></td></tr></table></figure>




<pre><code>datetime.datetime(2015, 7, 4, 0, 0)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对字符串格式的日期进行解析</span></span><br><span class="line"><span class="keyword">from</span> dateutil <span class="keyword">import</span> parser</span><br><span class="line">date = parser.parse(<span class="string">"4th of July, 2015"</span>)</span><br><span class="line">date</span><br></pre></td></tr></table></figure>




<pre><code>datetime.datetime(2015, 7, 4, 0, 0)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date.strftime(<span class="string">'%A'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&apos;Saturday&apos;</code></pre><ol start="2">
<li>Numpy的datetime64</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">date = np.array(<span class="string">'2015-07-04'</span>, dtype=np.datetime64)</span><br><span class="line">date</span><br></pre></td></tr></table></figure>




<pre><code>array(&apos;2015-07-04&apos;, dtype=&apos;datetime64[D]&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date + np.arange(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([&apos;2015-07-04&apos;, &apos;2015-07-05&apos;, &apos;2015-07-06&apos;, &apos;2015-07-07&apos;,
       &apos;2015-07-08&apos;, &apos;2015-07-09&apos;, &apos;2015-07-10&apos;, &apos;2015-07-11&apos;,
       &apos;2015-07-12&apos;, &apos;2015-07-13&apos;, &apos;2015-07-14&apos;, &apos;2015-07-15&apos;],
      dtype=&apos;datetime64[D]&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以分钟为单位</span></span><br><span class="line">date = np.datetime64(<span class="string">'2015-07-04 12:00'</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date + np.arange(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>




<pre><code>array([&apos;2015-07-04T12:00&apos;, &apos;2015-07-04T12:01&apos;, &apos;2015-07-04T12:02&apos;,
       &apos;2015-07-04T12:03&apos;, &apos;2015-07-04T12:04&apos;, &apos;2015-07-04T12:05&apos;,
       &apos;2015-07-04T12:06&apos;, &apos;2015-07-04T12:07&apos;, &apos;2015-07-04T12:08&apos;,
       &apos;2015-07-04T12:09&apos;, &apos;2015-07-04T12:10&apos;, &apos;2015-07-04T12:11&apos;],
      dtype=&apos;datetime64[m]&apos;)</code></pre><ol start="3">
<li>pandas 的日期与时间</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date = pd.to_datetime(<span class="string">"4th of July, 2015"</span>)</span><br><span class="line">date</span><br></pre></td></tr></table></figure>




<pre><code>Timestamp(&apos;2015-07-04 00:00:00&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date.strftime(<span class="string">'%A'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>&apos;Saturday&apos;</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date + pd.to_timedelta(np.arange(<span class="number">12</span>), <span class="string">'D'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>DatetimeIndex([&apos;2015-07-04&apos;, &apos;2015-07-05&apos;, &apos;2015-07-06&apos;, &apos;2015-07-07&apos;,
               &apos;2015-07-08&apos;, &apos;2015-07-09&apos;, &apos;2015-07-10&apos;, &apos;2015-07-11&apos;,
               &apos;2015-07-12&apos;, &apos;2015-07-13&apos;, &apos;2015-07-14&apos;, &apos;2015-07-15&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=None)</code></pre><h2 id="Pandas时间序列"><a href="#Pandas时间序列" class="headerlink" title="Pandas时间序列"></a>Pandas时间序列</h2><p>Pandas 时间序列工具非常适合用来处理带时间戳的索引数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">index = pd.DatetimeIndex([<span class="string">'2014-07-04'</span>, <span class="string">'2014-08-04'</span>,</span><br><span class="line">                         <span class="string">'2015-07-04'</span>, <span class="string">'2015-08-04'</span>])</span><br><span class="line">data = pd.Series([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], index = index)</span><br><span class="line">data</span><br></pre></td></tr></table></figure>




<pre><code>2014-07-04    0
2014-08-04    1
2015-07-04    2
2015-08-04    3
dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'2014-07-04'</span>:<span class="string">'2015-07-04'</span>]</span><br></pre></td></tr></table></figure>




<pre><code>2014-07-04    0
2014-08-04    1
2015-07-04    2
dtype: int64</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data[<span class="string">'2015'</span>]</span><br></pre></td></tr></table></figure>




<pre><code>2015-07-04    2
2015-08-04    3
dtype: int64</code></pre><h2 id="Pandas时间序列数据结构"><a href="#Pandas时间序列数据结构" class="headerlink" title="Pandas时间序列数据结构"></a>Pandas时间序列数据结构</h2><ul>
<li>时间戳数据： <code>Timestamp</code></li>
<li>时间周期：<code>Period</code></li>
<li>时间增量和持续时间：<code>Timedelta</code></li>
</ul>
<p>最基础的日期 / 时间对象是 Timestamp 和 DatetimeIndex。这两种对象可以直接使用，最常用<br>的方法是 pd.to_datetime() 函数，它可以解析许多日期与时间格式。对 pd.to_datetime() 传<br>递一个日期会返回一个 Timestamp 类型，传递一个时间序列会返回一个 DatetimeIndex 类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.to_datetime([datetime(<span class="number">2015</span>, <span class="number">7</span>, <span class="number">3</span>), <span class="string">'4th of July, 2015'</span>,<span class="string">'2015-Jul-6'</span>, <span class="string">'07-07-2015'</span>, <span class="string">'20150708'</span>])</span><br><span class="line">dates</span><br></pre></td></tr></table></figure>




<pre><code>DatetimeIndex([&apos;2015-07-03&apos;, &apos;2015-07-04&apos;, &apos;2015-07-06&apos;, &apos;2015-07-07&apos;,
               &apos;2015-07-08&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=None)</code></pre><p>任何 DatetimeIndex 类型都可以通过 to_period() 方法和一个频率代码转换成 PeriodIndex<br>类型。下面用 ‘D’ 将数据转换成单日的时间序列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dates.to_period(<span class="string">'D'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>PeriodIndex([&apos;2015-07-03&apos;, &apos;2015-07-04&apos;, &apos;2015-07-06&apos;, &apos;2015-07-07&apos;,
             &apos;2015-07-08&apos;],
            dtype=&apos;period[D]&apos;, freq=&apos;D&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dates - dates[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>




<pre><code>TimedeltaIndex([&apos;0 days&apos;, &apos;1 days&apos;, &apos;3 days&apos;, &apos;4 days&apos;, &apos;5 days&apos;], dtype=&apos;timedelta64[ns]&apos;, freq=None)</code></pre><p>为了能更简便地创建有规律的时间序列， Pandas 提供了一些方法： pd.date_range() 可以<br>处理时间戳、 pd.period_range() 可以处理周期、 pd.timedelta_range() 可以处理时间间<br>隔。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.date_range(<span class="string">'2015-07-03'</span>, <span class="string">'2015-07-10'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>DatetimeIndex([&apos;2015-07-03&apos;, &apos;2015-07-04&apos;, &apos;2015-07-05&apos;, &apos;2015-07-06&apos;,
               &apos;2015-07-07&apos;, &apos;2015-07-08&apos;, &apos;2015-07-09&apos;, &apos;2015-07-10&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.date_range(<span class="string">'2015-07-03'</span>, periods=<span class="number">8</span>)</span><br></pre></td></tr></table></figure>




<pre><code>DatetimeIndex([&apos;2015-07-03&apos;, &apos;2015-07-04&apos;, &apos;2015-07-05&apos;, &apos;2015-07-06&apos;,
               &apos;2015-07-07&apos;, &apos;2015-07-08&apos;, &apos;2015-07-09&apos;, &apos;2015-07-10&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=&apos;D&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># D:day H: hour</span></span><br><span class="line">pd.date_range(<span class="string">'2015-07-03'</span>, periods=<span class="number">8</span>, freq=<span class="string">'H'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>DatetimeIndex([&apos;2015-07-03 00:00:00&apos;, &apos;2015-07-03 01:00:00&apos;,
               &apos;2015-07-03 02:00:00&apos;, &apos;2015-07-03 03:00:00&apos;,
               &apos;2015-07-03 04:00:00&apos;, &apos;2015-07-03 05:00:00&apos;,
               &apos;2015-07-03 06:00:00&apos;, &apos;2015-07-03 07:00:00&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=&apos;H&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.period_range(<span class="string">'2015-07'</span>, periods=<span class="number">8</span>, freq=<span class="string">'M'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>PeriodIndex([&apos;2015-07&apos;, &apos;2015-08&apos;, &apos;2015-09&apos;, &apos;2015-10&apos;, &apos;2015-11&apos;, &apos;2015-12&apos;,
             &apos;2016-01&apos;, &apos;2016-02&apos;],
            dtype=&apos;period[M]&apos;, freq=&apos;M&apos;)</code></pre><h2 id="时间频率与偏移量"><a href="#时间频率与偏移量" class="headerlink" title="时间频率与偏移量"></a>时间频率与偏移量</h2><table>
<thead>
<tr>
<th>代码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>D</td>
<td>天</td>
</tr>
<tr>
<td>W</td>
<td>周</td>
</tr>
<tr>
<td>M</td>
<td>月</td>
</tr>
<tr>
<td>Q</td>
<td>季度</td>
</tr>
<tr>
<td>A</td>
<td>年</td>
</tr>
<tr>
<td>H</td>
<td>小时</td>
</tr>
<tr>
<td>T</td>
<td>分钟</td>
</tr>
<tr>
<td>S</td>
<td>秒</td>
</tr>
<tr>
<td>B</td>
<td>天（只含工作日）</td>
</tr>
<tr>
<td>BH</td>
<td>小时（只含工作小时）</td>
</tr>
</tbody></table>
<p>月、季、年频率都是具体周期的结束时间（月末、季末、年末），而有一些以 S（start，开<br>始）为后缀的代码表示日期开始</p>
<table>
<thead>
<tr>
<th>代码</th>
<th>频率</th>
</tr>
</thead>
<tbody><tr>
<td>MS</td>
<td>月初（month start）</td>
</tr>
<tr>
<td>BMS</td>
<td>月初（business month start，仅含工作日）</td>
</tr>
<tr>
<td>QS</td>
<td>季初（quarter start）</td>
</tr>
<tr>
<td>BQS</td>
<td>季初（business quarter start，仅含工作日）</td>
</tr>
<tr>
<td>AS</td>
<td>年初（year start）</td>
</tr>
<tr>
<td>BAS</td>
<td>年初（business year start，仅含工作日）</td>
</tr>
</tbody></table>
<p>另外，你可以在频率代码后面加三位月份缩写字母来改变季、年频率的开始时间。<br>• Q-JAN、 BQ-FEB、 QS-MAR、 BQS-APR 等。<br>• A-JAN、 BA-FEB、 AS-MAR、 BAS-APR 等。<br>同理，也可以在后面加三位星期缩写字母来改变一周的开始时间。<br>• W-SUN、 W-MON、 W-TUE、 W-WED 等。  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pd.timedelta_range(<span class="number">0</span>, periods=<span class="number">9</span>, freq=<span class="string">"2H30T"</span>)</span><br></pre></td></tr></table></figure>




<pre><code>TimedeltaIndex([&apos;00:00:00&apos;, &apos;02:30:00&apos;, &apos;05:00:00&apos;, &apos;07:30:00&apos;, &apos;10:00:00&apos;,
                &apos;12:30:00&apos;, &apos;15:00:00&apos;, &apos;17:30:00&apos;, &apos;20:00:00&apos;],
               dtype=&apos;timedelta64[ns]&apos;, freq=&apos;150T&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> BDay</span><br><span class="line">pd.date_range(<span class="string">'2015-07-01'</span>, periods=<span class="number">5</span>, freq=BDay())</span><br></pre></td></tr></table></figure>




<pre><code>DatetimeIndex([&apos;2015-07-01&apos;, &apos;2015-07-02&apos;, &apos;2015-07-03&apos;, &apos;2015-07-06&apos;,
               &apos;2015-07-07&apos;],
              dtype=&apos;datetime64[ns]&apos;, freq=&apos;B&apos;)</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://luyilin.top/2020/09/16/%E4%BC%9A%E8%AE%A1%E5%AD%A6/%E6%80%BB%E8%AE%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="luyilin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="引而不发，跃如也">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/16/%E4%BC%9A%E8%AE%A1%E5%AD%A6/%E6%80%BB%E8%AE%BA/" class="post-title-link" itemprop="url">会计学/总论</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-16 08:12:32" itemprop="dateCreated datePublished" datetime="2020-09-16T08:12:32+08:00">2020-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-17 14:22:43" itemprop="dateModified" datetime="2020-09-17T14:22:43+08:00">2020-09-17</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%BC%9A%E8%AE%A1%E5%AD%A6/" itemprop="url" rel="index"><span itemprop="name">会计学</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="概念和特点"><a href="#概念和特点" class="headerlink" title="概念和特点"></a>概念和特点</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>以货币为主要量度</li>
<li>运用专门方法</li>
<li>对会计主体的经济活动</li>
<li>进行管理和监督，收集处理和提供管理决策需要的经济信息</li>
<li>并利用经济信息对经济活动进行组织、控制、调节和指导</li>
<li>以提高经济效益的一种管理活动</li>
</ul>
<p><strong>国际会计准则</strong>：</p>
<ul>
<li>一个过程</li>
<li>确认(identifying)-计量(measuring)-纪录(recording)-传递（communicating）</li>
<li>经济信息</li>
<li>做出决策</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>以货币为主要计量单位</li>
<li>以真实、合法的会计凭证为依据</li>
<li>对经济活动进项全面、连续、系统、综合的核算和监督</li>
</ol>
<h2 id="产生和发展"><a href="#产生和发展" class="headerlink" title="产生和发展"></a>产生和发展</h2><ul>
<li><p>四柱清册</p>
<p>实在 = 旧营 + 新收 - 开除</p>
</li>
<li><p>威尼斯薄记法</p>
</li>
<li><p>现代会计</p>
<p>客观环境： 股份有限公司出现，使得所有权和经营权相分离</p>
<p>第三方验证</p>
<p>资产量化</p>
</li>
<li><p>计算机技术</p>
</li>
</ul>
<h1 id="会计的职能和目标"><a href="#会计的职能和目标" class="headerlink" title="会计的职能和目标"></a>会计的职能和目标</h1><h2 id="会计职能"><a href="#会计职能" class="headerlink" title="会计职能"></a>会计职能</h2><ul>
<li>基本职能 : 核算、监督</li>
<li>管理职能： 预测、 决策、 控制、 分析</li>
</ul>
<h2 id="会计目标"><a href="#会计目标" class="headerlink" title="会计目标"></a>会计目标</h2><p>会计目标值会计活动索要达到的目的，也称为会计报表目标</p>
<ul>
<li>向报表使用者提供与企业财务状况，精英成果和现金流量等有关的会计信息</li>
<li>反应企业管理层受托责任履行情况</li>
<li>有助于报表使用者做出经济决策</li>
</ul>
<h2 id="主要财务报表"><a href="#主要财务报表" class="headerlink" title="主要财务报表"></a>主要财务报表</h2><ul>
<li>资产负债表——企业财务状况：企业拥有的资源以及资源的来源</li>
<li>损益表——经营成果：资源使用后的结果</li>
<li>现金流量表——现金流量</li>
</ul>
<h3 id="资产负债表"><a href="#资产负债表" class="headerlink" title="资产负债表"></a>资产负债表</h3><ul>
<li>瞬间</li>
</ul>
<p>资产 = 负债 + 所有者权益 （A = L + OE）</p>
<p>资产： 流动 + 非流动</p>
<p>负债： 流动 + 长期</p>
<p>所有者权益： </p>
<ul>
<li>总股本（实收资本）—— 输血</li>
<li>留存收益 —— 造血</li>
<li>等价于净资产</li>
</ul>
<h3 id="损益表"><a href="#损益表" class="headerlink" title="损益表"></a>损益表</h3><ul>
<li>动态 一段时间</li>
<li>说清留存收益的变化情况</li>
</ul>
<h3 id="现金流量表"><a href="#现金流量表" class="headerlink" title="现金流量表"></a>现金流量表</h3><p>经营、投资、筹资</p>
<h1 id="会计规范"><a href="#会计规范" class="headerlink" title="会计规范"></a>会计规范</h1><ul>
<li><p>会计法律</p>
<ul>
<li>根本大法《中华人民共和国会计法》  </li>
<li>由全国人民代表大会极其常务委员会制定和发布</li>
</ul>
</li>
<li><p>会计准则</p>
<ul>
<li><p>基本规范，从业人员工作规则和指南</p>
</li>
<li><p>由财政部门制定颁布</p>
</li>
<li><p>由基本原则、具体准则、应用指南三部分构成</p>
<ul>
<li>基本准则：规定会计<strong>目标</strong>、会计核算的<strong>基本前提</strong>、会计<strong>要素</strong>、会计信息<strong>质量要求</strong>、会计<strong>计量属性</strong>以及财务<strong>会计报告的基本要求</strong></li>
<li>具体会计准则：根据基本会计准则的要求对各类经济业务的<strong>确认、计量、纪录和报告</strong>作出的具体规定</li>
</ul>
</li>
</ul>
</li>
<li><p>会计制度</p>
<p> 根据会计法和会计准则所指定的具体规章、方法和程序的总称</p>
<p>  现行企业会计制度</p>
<ul>
<li>《企业会计制度》</li>
<li>《金融企业会计制度》</li>
<li>《小企业会计制度》</li>
</ul>
</li>
</ul>
<h1 id="会计假设和会计基本原则"><a href="#会计假设和会计基本原则" class="headerlink" title="会计假设和会计基本原则"></a>会计假设和会计基本原则</h1><h2 id="会计假设"><a href="#会计假设" class="headerlink" title="会计假设"></a>会计假设</h2><p>又称为会计核算的基本前提</p>
<ul>
<li>会计主体假设</li>
<li>持续经营假设</li>
<li>会计分期假设</li>
<li>货币计量假设</li>
</ul>
<ol>
<li><p>会计主体假设<br>会计主体：会计为其服务的特定单位或组织（需要报告会计信息的，与法人实体不同）</p>
<p>会计主体假设了规范了会计工作的空间范围</p>
<p>可以是企业，事业单位，集团公司  </p>
<p>法人主体一定是会计主体，会计主体不一定是法人实体</p>
<p>法律主体 $\ne$ 会计主体<br>一个法律主体可以分割成若干个会计主体<br>几个法律主体可以合并为一个会计主体</p>
</li>
<li><p>持续经营假设<br>持续经营假设是指会计主体的生产经营活动会议目前的状态长期经营下去，而不会发生破产和清算。</p>
<p>持续经营假设是对企业经营时间的界定</p>
</li>
<li><p>会计分期假设<br>因为企业持续经营，会计人员要定期为会计信息使用者提供关于企业财务状况和精英成果的信息，因此必须将持续不断的经营过程划分为若干个阶段</p>
<p>人为的划分</p>
</li>
<li><p>货币计量假设<br>货币计量假设是指会计在核算企业经营活动和财务成果时，一律以货币为计量单位，并<strong>假定作为计量手段的货币价值不变</strong></p>
<p>会计核算的内容仅限于能够用货币计量的经济业务</p>
<p><strong>所有的会计信息都是企业的重要信息，而不是企业所有的重要信息都能够成为会计信息</strong></p>
</li>
</ol>
<h2 id="会计基本原则"><a href="#会计基本原则" class="headerlink" title="会计基本原则"></a>会计基本原则</h2><ul>
<li>可靠性原则</li>
<li>相关性原则</li>
<li>可理解性原则</li>
<li>可比性原则</li>
<li>实质重于形式原则</li>
<li>重要性原则</li>
<li>谨慎性原则</li>
<li>及时性原则</li>
</ul>
<ol>
<li>可靠性原则<br>又称真实性，指企业会计核算应以实际大声的交易或事项为依据<br>具体包括三个方面：内容真实 不能虚作假、数据可靠、证据确凿</li>
<li>相关性原则<br>又称有用性，指企业提供的会计信息要与信息使用者的经济决策需要相关联，有助于信息使用者根据会计信息了解企业的过去，评价企业的现在，也测企业的未来</li>
</ol>
<ul>
<li>会计信息有用性是信息价值的本质体现，信息价值的大小在于其对信息使用者的有用程度</li>
</ul>
<ol start="3">
<li><p>可理解性原则<br>会计信息应当清楚明了</p>
</li>
<li><p>可比性<br>口径一致，相互可比</p>
</li>
<li><p>实质重于形式原则</p>
</li>
</ol>
<p>   实质——经济实质</p>
<p>   形式——法律形式</p>
<p>   如：长租相当于长期资产，虽然在法律上并不长期拥有<br>6. 重要性原则<br>   对于影响经营决策的重要经事项应当进行详细核算，单独反映</p>
<p>   判断经济事项是否重要： 性质，金额</p>
<ol start="7">
<li><p>谨慎性原则<br> 从不高估资产或收益，从不低估负债（损失）或费用</p>
</li>
<li><p>及时性原则<br>时效性</p>
</li>
</ol>
<h1 id="会计处理基础和会计计量属性"><a href="#会计处理基础和会计计量属性" class="headerlink" title="会计处理基础和会计计量属性"></a>会计处理基础和会计计量属性</h1><h2 id="会计处理基础"><a href="#会计处理基础" class="headerlink" title="会计处理基础"></a>会计处理基础</h2><p>是指确认会计事项<strong>归属期间</strong>的标准操作</p>
<ul>
<li>收付实现制</li>
<li>权责发生制：在权力，责任，义务转移时产生的会计信息</li>
</ul>
<p>预付款 $\ne$ 收入（要给出服务）</p>
<ol>
<li><p>收付实现制<br>收入：本期销售本期收获 + 前期销售本期收获 + 尚未销售本期收获</p>
<p>费用：本期收益 + 上期收益的应计费用 + 下期收益的预付费用</p>
</li>
<li><p>权责发生制<br>凡是本期已实现的收入，不论款项是否收到，都作为本期收入</p>
<p>凡是应有本期承担的费用，不论款项是否之父都应作为本期费用</p>
<p>凡是不属于本期的收入和费用， 即使款项在本期收付，也不应作为本期的收入和费用</p>
<p> <strong>收入与费用的确认与现金的流入和流出没有必然的联系</strong></p>
</li>
</ol>
<ul>
<li><p>每个会计期间的收入包括：  </p>
<ol>
<li>本期销售商品已收到货款和尚未收到货款（应收账款）的收入</li>
<li>商品在本期发出，并与前期预收货款的收入（权责转移，预付款）</li>
</ol>
</li>
<li><p>每个会计期间的费用包括：  </p>
<ol>
<li>本期支付的，应有本期负担的费用</li>
<li>前期支付的，应有本期复旦的待摊费用（预付费用）</li>
<li>本期尚未之父，但应由本期负担的预提费用（应付费用）</li>
</ol>
</li>
<li><p>权责发生制体现了配比的原则确定的当期损益更加恰当</p>
</li>
<li><p>权责发生制的<strong>内涵延伸</strong>：</p>
<ul>
<li><p>划分<strong>收益性支出</strong>与<strong>资本性支出</strong></p>
<table>
<thead>
<tr>
<th>收益性支出</th>
<th>资本性支出</th>
</tr>
</thead>
<tbody><tr>
<td>支出的效益与<strong>本年度</strong>相关</td>
<td>支出的效益可以<strong>递延到几个会计年度</strong></td>
</tr>
<tr>
<td>作为费用，列入利润表</td>
<td>作为资产，列入资产负债表</td>
</tr>
<tr>
<td>作为费用从当期收入扣除进而减少当期经营成果</td>
<td>资产状态的转换形式，不是费用，不会减少当期经营成果</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>收益性业务</th>
<th>资本性业务</th>
</tr>
</thead>
<tbody><tr>
<td>只影响本期业绩的业务</td>
<td>影响若干期业绩的业务</td>
</tr>
</tbody></table>
<p>  由于经济业务发生的直接表现是货币支出，因此习惯地价格收益性业务成为收益性支出，资本性业务成为资本性支出</p>
<p>  划分收益性支出和资本性支出的目的：<br>  正确的反应某个会计期间的财务状况和经营成果</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>收入和费用<strong>相配比</strong> </p>
<p> 若只确认收入不确认费用，则当期的利润虚假增加<br> 若只确认费用不确认收入，则当期的利润减少</p>
</li>
</ul>
<h2 id="会计的计量属性"><a href="#会计的计量属性" class="headerlink" title="会计的计量属性"></a>会计的计量属性</h2><ul>
<li>历史成本</li>
<li>重置成本</li>
<li>可变现净值</li>
<li>现值</li>
<li>公允价值</li>
</ul>
<p>计量属性使用的基本要求：</p>
<ul>
<li>企业对会计要素进行计量时，一般应当采用历史成本</li>
<li>采用重置成本、可变现净值、现值、公允价值计量的，应当保证确定的会计要素能够取得可靠的计量。</li>
</ul>
<ol>
<li>历史成本  </li>
</ol>
<ul>
<li><p>又称<strong>实际成本</strong>，指企业取得某项资产时的<strong>原始交易价格</strong></p>
</li>
<li><p>企业的各项资产应按其取得时的实际成本即原始交易价格进行核算</p>
</li>
<li><p>历史成本计量属性的应用处于<strong>主导地位</strong></p>
</li>
</ul>
<ol start="2">
<li>重置成本  </li>
</ol>
<ul>
<li><p>又称现行成本，是指企业在<strong>当前的市场条件下</strong>，<strong>重新取得</strong>同样的资产所需要支付的<strong>交易价格</strong> </p>
</li>
<li><p>无论资产还是负债都应该按现在的价格进行计算</p>
</li>
<li><p>确定重置成本比较困难，无法与原有资产完全吻合，从而影响会计信息的可靠性</p>
</li>
</ul>
<ol start="3">
<li>可变现净值  </li>
</ol>
<ul>
<li>又称脱手价值，是指资产在正常的销售或处置时，带来的现金流入和现金流出后相抵后的净额</li>
<li>不考虑货币的时间价值</li>
<li>可变现净值反应的是资产的现实价值，与管理决策相关性比较强，适用于对存货资产价值的估计和计量。</li>
</ul>
<ol start="4">
<li>现值  </li>
</ol>
<ul>
<li>是指未来期间现金流量的贴现价值</li>
<li>需要考虑货币的时间价值</li>
<li>在现值计量属性下，资产按预计从其持续经营使用和最终处置中所产生的的未来净现金流入量的折现金额计量</li>
<li>负债按照预计期限内需要偿还的未来净夏津流出量的折现金额计量。</li>
</ul>
<ol start="5">
<li>公允价值</li>
</ol>
<ul>
<li>指在熟悉市场环境的条件下交易双方都能够接受的价格（市场价）</li>
<li>资产和负债按双方自愿的金额计量</li>
<li>公允价值的使用条件非常严格（不能为关联企业）</li>
<li>相对于历史成本信息更能反映市场对企业资产或整体价值的评价，更具相关性</li>
<li>有一定复杂性，不确定性和高成本；主要应用于金融资产和投资性房产的计量</li>
</ul>
<h1 id="基本会计等式"><a href="#基本会计等式" class="headerlink" title="基本会计等式"></a>基本会计等式</h1><p>资产 = 负债 + 所有者权益</p>
<p>净资产 = 所有者权益</p>
<p>收入 - 费用 = 所有者权益</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://luyilin.top/2020/09/11/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/sklearn-%E5%86%B3%E7%AD%96%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="luyilin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="引而不发，跃如也">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/11/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/sklearn-%E5%86%B3%E7%AD%96%E6%A0%91/" class="post-title-link" itemprop="url">数据挖掘/sklearn-决策树</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-11 15:20:23 / Modified: 15:24:01" itemprop="dateCreated datePublished" datetime="2020-09-11T15:20:23+08:00">2020-09-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/sklearn/" itemprop="url" rel="index"><span itemprop="name">sklearn</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="加载数据集"><a href="#加载数据集" class="headerlink" title="加载数据集"></a>加载数据集</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data_name = <span class="string">'basketball.csv'</span></span><br><span class="line">dataset = pd.read_csv(data_name)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataset.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Date</th>
      <th>Start (ET)</th>
      <th>Visitor/Neutral</th>
      <th>PTS</th>
      <th>Home/Neutral</th>
      <th>PTS.1</th>
      <th>Unnamed: 6</th>
      <th>Unnamed: 7</th>
      <th>Attend.</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>Tue Oct 27 2015</td>
      <td>8:00p</td>
      <td>Cleveland Cavaliers</td>
      <td>95</td>
      <td>Chicago Bulls</td>
      <td>97</td>
      <td>Box Score</td>
      <td>NaN</td>
      <td>21957</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>Tue Oct 27 2015</td>
      <td>8:00p</td>
      <td>Detroit Pistons</td>
      <td>106</td>
      <td>Atlanta Hawks</td>
      <td>94</td>
      <td>Box Score</td>
      <td>NaN</td>
      <td>19187</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>Tue Oct 27 2015</td>
      <td>10:30p</td>
      <td>New Orleans Pelicans</td>
      <td>95</td>
      <td>Golden State Warriors</td>
      <td>111</td>
      <td>Box Score</td>
      <td>NaN</td>
      <td>19596</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>Wed Oct 28 2015</td>
      <td>7:00p</td>
      <td>Washington Wizards</td>
      <td>88</td>
      <td>Orlando Magic</td>
      <td>87</td>
      <td>Box Score</td>
      <td>NaN</td>
      <td>18846</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>Wed Oct 28 2015</td>
      <td>7:30p</td>
      <td>Philadelphia 76ers</td>
      <td>95</td>
      <td>Boston Celtics</td>
      <td>112</td>
      <td>Box Score</td>
      <td>NaN</td>
      <td>18624</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



<h1 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h1><ol>
<li>日期内容是字符串而不是日期对象</li>
<li>表头不完整或不正确</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dataset = pd.read_csv(data_name, parse_dates=[<span class="string">"Date"</span>])</span><br><span class="line">dataset.columns = [<span class="string">"Date"</span>, <span class="string">"Start (ET)"</span>, <span class="string">"Visitor Team"</span>, <span class="string">"VisitorPts"</span>,</span><br><span class="line">                    <span class="string">"Home Team"</span>, <span class="string">"HomePts"</span>, <span class="string">"OT?"</span>, <span class="string">"Score Type"</span>,<span class="string">"Attend"</span>,<span class="string">"Notes"</span>]</span><br><span class="line">dataset.head()</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Date</th>
      <th>Start (ET)</th>
      <th>Visitor Team</th>
      <th>VisitorPts</th>
      <th>Home Team</th>
      <th>HomePts</th>
      <th>OT?</th>
      <th>Score Type</th>
      <th>Attend</th>
      <th>Notes</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2015-10-27</td>
      <td>8:00p</td>
      <td>Cleveland Cavaliers</td>
      <td>95</td>
      <td>Chicago Bulls</td>
      <td>97</td>
      <td>Box Score</td>
      <td>NaN</td>
      <td>21957</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2015-10-27</td>
      <td>8:00p</td>
      <td>Detroit Pistons</td>
      <td>106</td>
      <td>Atlanta Hawks</td>
      <td>94</td>
      <td>Box Score</td>
      <td>NaN</td>
      <td>19187</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2015-10-27</td>
      <td>10:30p</td>
      <td>New Orleans Pelicans</td>
      <td>95</td>
      <td>Golden State Warriors</td>
      <td>111</td>
      <td>Box Score</td>
      <td>NaN</td>
      <td>19596</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2015-10-28</td>
      <td>7:00p</td>
      <td>Washington Wizards</td>
      <td>88</td>
      <td>Orlando Magic</td>
      <td>87</td>
      <td>Box Score</td>
      <td>NaN</td>
      <td>18846</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2015-10-28</td>
      <td>7:30p</td>
      <td>Philadelphia 76ers</td>
      <td>95</td>
      <td>Boston Celtics</td>
      <td>112</td>
      <td>Box Score</td>
      <td>NaN</td>
      <td>18624</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



<h1 id="提取新特征"><a href="#提取新特征" class="headerlink" title="提取新特征"></a>提取新特征</h1><p>将主队获胜的情况编码为 1，将客队获胜的情况编码为 0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataset[<span class="string">"HomeWin"</span>] = dataset[<span class="string">"VisitorPts"</span>] &lt; dataset[<span class="string">"HomePts"</span>]</span><br></pre></td></tr></table></figure>

<p>切换成numpy格式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_true = dataset[<span class="string">"HomeWin"</span>].values</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y_true</span><br></pre></td></tr></table></figure>




<pre><code>array([ True, False,  True, ..., False,  True, False])</code></pre><p>计算新特征，方法是按顺序迭代各行，并记录获胜队伍。每迭代到一行新数据，<br>就去查找当前两支队伍上一次交手的结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">won_last = defaultdict(int)</span><br><span class="line">dataset[<span class="string">"HomeLastWin"</span>] = <span class="number">0</span></span><br><span class="line">dataset[<span class="string">"VisitorLastWin"</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index,row <span class="keyword">in</span> dataset.iterrows():</span><br><span class="line">    home_team = row[<span class="string">"Home Team"</span>]</span><br><span class="line">    visitor_team = row[<span class="string">"Visitor Team"</span>]</span><br><span class="line">    row[<span class="string">"HomeLastWin"</span>] = won_last[home_team]</span><br><span class="line">    dataset.set_value(index, <span class="string">"HomeLastWin"</span>, won_last[home_team])</span><br><span class="line">    dataset.set_value(index, <span class="string">"VisitorLastWin"</span>, won_last[visitor_team])</span><br><span class="line">    won_last[home_team] = int(row[<span class="string">"HomeWin"</span>])</span><br><span class="line">    won_last[visitor_team] = <span class="number">1</span> - int(row[<span class="string">"HomeWin"</span>])</span><br></pre></td></tr></table></figure>




<p>​    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataset.head(<span class="number">6</span>)</span><br></pre></td></tr></table></figure>




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}</code></pre><p></style><p></p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Date</th>
      <th>Start (ET)</th>
      <th>Visitor Team</th>
      <th>VisitorPts</th>
      <th>Home Team</th>
      <th>HomePts</th>
      <th>OT?</th>
      <th>Score Type</th>
      <th>Attend</th>
      <th>Notes</th>
      <th>HomeWin</th>
      <th>HomeLastWin</th>
      <th>VisitorLastWin</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2015-10-27</td>
      <td>8:00p</td>
      <td>Cleveland Cavaliers</td>
      <td>95</td>
      <td>Chicago Bulls</td>
      <td>97</td>
      <td>Box Score</td>
      <td>NaN</td>
      <td>21957</td>
      <td>NaN</td>
      <td>True</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>1</th>
      <td>2015-10-27</td>
      <td>8:00p</td>
      <td>Detroit Pistons</td>
      <td>106</td>
      <td>Atlanta Hawks</td>
      <td>94</td>
      <td>Box Score</td>
      <td>NaN</td>
      <td>19187</td>
      <td>NaN</td>
      <td>False</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>2</th>
      <td>2015-10-27</td>
      <td>10:30p</td>
      <td>New Orleans Pelicans</td>
      <td>95</td>
      <td>Golden State Warriors</td>
      <td>111</td>
      <td>Box Score</td>
      <td>NaN</td>
      <td>19596</td>
      <td>NaN</td>
      <td>True</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>3</th>
      <td>2015-10-28</td>
      <td>7:00p</td>
      <td>Washington Wizards</td>
      <td>88</td>
      <td>Orlando Magic</td>
      <td>87</td>
      <td>Box Score</td>
      <td>NaN</td>
      <td>18846</td>
      <td>NaN</td>
      <td>False</td>
      <td>0</td>
      <td>1</td>
    </tr>
    <tr>
      <th>4</th>
      <td>2015-10-28</td>
      <td>7:30p</td>
      <td>Philadelphia 76ers</td>
      <td>95</td>
      <td>Boston Celtics</td>
      <td>112</td>
      <td>Box Score</td>
      <td>NaN</td>
      <td>18624</td>
      <td>NaN</td>
      <td>True</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>2015-10-28</td>
      <td>7:30p</td>
      <td>Chicago Bulls</td>
      <td>115</td>
      <td>Brooklyn Nets</td>
      <td>100</td>
      <td>Box Score</td>
      <td>NaN</td>
      <td>17732</td>
      <td>NaN</td>
      <td>False</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>



<h1 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h1><h2 id="决策树参数"><a href="#决策树参数" class="headerlink" title="决策树参数"></a>决策树参数</h2><figure class="highlight plain"><figcaption><span>指定创建决策新节点所需的最低样本数量。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;min_samples_leaf&#96;&#96;&#96; 指定保留节点所需的最低返回样本数量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">第一个参数决定是否创建决策节点，而第二个参数决定是否保留决策节点。</span><br><span class="line"></span><br><span class="line">指定决策创建条件的参数:</span><br><span class="line"></span><br><span class="line">1. 基尼不纯度 关注决策树节点错误预测样本分类的概率。</span><br><span class="line">2. 信息增益 用计算信息论熵的方式来衡量决策节点带来的额外信息量。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">from sklearn.tree import DecisionTreeClassifier</span><br><span class="line">clf &#x3D; DecisionTreeClassifier(random_state &#x3D; 14)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X_previouswins = dataset[[<span class="string">"HomeLastWin"</span>, <span class="string">"VisitorLastWin"</span>]].values</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> cross_val_score</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">scores = cross_val_score(clf, X_previouswins, y_true,</span><br><span class="line">                            scoring=<span class="string">'accuracy'</span>)</span><br><span class="line">print(<span class="string">"Accuracy: &#123;0:.1f&#125;%"</span>.format(np.mean(scores) * <span class="number">100</span>))</span><br></pre></td></tr></table></figure>

<pre><code>Accuracy: 58.1%</code></pre><h1 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h1><p>限制决策树要学习的规则的数量，并创建多颗决策树</p>
<p>问题：</p>
<ol>
<li>决策树的生成过程是确定的</li>
<li>用相似数据生成决策树是，前几个决策结点的特征也会差不多</li>
</ol>
<p>解决：</p>
<ol>
<li>在数据中随机采样，生成多份新的数据集</li>
<li>在分割数据时随机选取特征子集，以避免在不同决策树中出现相同特征</li>
</ol>
<p>通过对大量决策树的结果取平均，可以大大减小方差。这样得到的模型通常有更高的总体准<br>确率和更强的预测能力，但也增加了计算时间，并给算法带来了更高的偏差。</p>
<h2 id="随机森林参数"><a href="#随机森林参数" class="headerlink" title="随机森林参数"></a>随机森林参数</h2><p>随机森林会生成多个 DecisionTreeClassifier 实例，这些实例共用像 criterion（基<br>尼不纯度/熵增/信息增益）、 max_features、 min_samples_split 这样的参数。</p>
<p>一些新参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">也越准确。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;oob_score&#96;&#96;&#96;：如果结果为 True，那么该方法会在其他样本上进行测试，而不用训练决策</span><br><span class="line">树时所使用的那部分数据集。</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;n_jobs&#96;&#96;&#96;：指定参与并行计算生成决策树的 CPU 核心数量。</span><br><span class="line"></span><br><span class="line">## 应用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">from sklearn.ensemble import RandomForestClassifier</span><br><span class="line">clf &#x3D; RandomForestClassifier(random_state&#x3D;14)</span><br><span class="line">scores &#x3D; cross_val_score(clf, X_previouswins, y_true, scoring&#x3D;&#39;accuracy&#39;)</span><br><span class="line">print(&quot;Accuracy: &#123;0:.1f&#125;%&quot;.format(np.mean(scores) * 100))</span><br></pre></td></tr></table></figure>

<pre><code>Accuracy: 58.1%</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://luyilin.top/2020/09/09/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/sklearn-%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E4%B8%8E%E7%AE%80%E5%8D%95%E9%A2%84%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="luyilin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="引而不发，跃如也">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/09/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/sklearn-%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E4%B8%8E%E7%AE%80%E5%8D%95%E9%A2%84%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">数据挖掘/sklearn-分类问题与简单预处理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-09 09:33:47 / Modified: 09:37:33" itemprop="dateCreated datePublished" datetime="2020-09-09T09:33:47+08:00">2020-09-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/sklearn/" itemprop="url" rel="index"><span itemprop="name">sklearn</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>估计器的关键参数：</p>
<ol>
<li><code>fit()</code>:输入训练样本数据集以及样本对应的类别。</li>
<li><code>predict()</code>:仅以测试集类别为输入</li>
</ol>
<h1 id="最邻近算法"><a href="#最邻近算法" class="headerlink" title="最邻近算法"></a>最邻近算法</h1><p>距离： 欧几里得距离，曼哈顿距离，余弦距离</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data_name = <span class="string">"ionosphere.data"</span></span><br><span class="line">X = np.zeros((<span class="number">351</span>,<span class="number">34</span>),dtype = <span class="string">'float'</span>)</span><br><span class="line">y = np.zeros((<span class="number">351</span>,),dtype = <span class="string">'bool'</span>)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(data_name, <span class="string">'r'</span>) <span class="keyword">as</span> input_file:</span><br><span class="line">    reader = csv.reader(input_file)</span><br><span class="line">    <span class="keyword">for</span> i, row <span class="keyword">in</span> enumerate(reader):</span><br><span class="line">        <span class="comment"># 取出数据，转换为浮点类型</span></span><br><span class="line">        data = [float(datum) <span class="keyword">for</span> datum <span class="keyword">in</span> row[:<span class="number">-1</span>]]</span><br><span class="line">        <span class="comment"># 向 X 中填入合适的行</span></span><br><span class="line">        X[i] = data</span><br><span class="line">        <span class="comment"># 如果类别是'g'则为 1，否则为 0</span></span><br><span class="line">        y[i] = row[<span class="number">-1</span>] == <span class="string">'g'</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分割训练集与测试集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X,y,random_state = <span class="number">14</span>)</span><br></pre></td></tr></table></figure>

<pre><code>C:\Users\25827\Anaconda3\lib\site-packages\sklearn\cross_validation.py:41: DeprecationWarning: This module was deprecated in version 0.18 in favor of the model_selection module into which all the refactored classes and functions are moved. Also note that the interface of the new CV iterators are different from that of this module. This module will be removed in 0.20.
  &quot;This module will be removed in 0.20.&quot;, DeprecationWarning)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建估计器</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">estimator = KNeighborsClassifier()</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">estimator.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>




<pre><code>KNeighborsClassifier(algorithm=&apos;auto&apos;, leaf_size=30, metric=&apos;minkowski&apos;,
           metric_params=None, n_jobs=1, n_neighbors=5, p=2,
           weights=&apos;uniform&apos;)</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  评估效果</span></span><br><span class="line">y_predicted = estimator.predict(X_test)</span><br><span class="line">accuracy = np.mean(y_test == y_predicted) * <span class="number">100</span></span><br><span class="line">print(accuracy)</span><br></pre></td></tr></table></figure>

<pre><code>86.36363636363636</code></pre><h2 id="交叉验证"><a href="#交叉验证" class="headerlink" title="交叉验证"></a>交叉验证</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cross_validation <span class="keyword">import</span> cross_val_score</span><br><span class="line">scores = cross_val_score(estimator, X ,y ,scoring = <span class="string">'accuracy'</span>)</span><br><span class="line">average_accuracy = np.mean(scores)* <span class="number">100</span></span><br><span class="line">print(average_accuracy)</span><br></pre></td></tr></table></figure>

<pre><code>82.33618233618233</code></pre><h2 id="参数选择"><a href="#参数选择" class="headerlink" title="参数选择"></a>参数选择</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">avg_scores = []</span><br><span class="line">all_scores = []</span><br><span class="line">parameter_values = list(range(<span class="number">1</span>,<span class="number">21</span>))</span><br><span class="line"><span class="keyword">for</span> n_neighbors <span class="keyword">in</span> parameter_values:</span><br><span class="line">    estimator = KNeighborsClassifier(n_neighbors=n_neighbors)</span><br><span class="line">    scores = cross_val_score(estimator, X, y, scoring=<span class="string">'accuracy'</span>)</span><br><span class="line">    avg_scores.append(np.mean(scores))</span><br><span class="line">    all_scores.append(scores)</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.plot(parameter_values, avg_scores, <span class="string">'-o'</span>)</span><br></pre></td></tr></table></figure>




<pre><code>[&lt;matplotlib.lines.Line2D at 0x16ac2bdac50&gt;]</code></pre><p><img src="/2020/09/09/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/sklearn-%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E4%B8%8E%E7%AE%80%E5%8D%95%E9%A2%84%E5%A4%84%E7%90%86/output_14_1.png" alt="png"></p>
<p>选取的近邻数量越多，算法的准确率越低</p>
<h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><h2 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h2><p>使所有值落在[0,1]之间</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X_transformed = MinMaxScaler().fit_transform(X)</span><br><span class="line">X_transformed</span><br></pre></td></tr></table></figure>




<pre><code>array([[1.      , 0.      , 0.997695, ..., 0.227565, 0.593205, 0.2735  ],
       [1.      , 0.      , 1.      , ..., 0.46856 , 0.43131 , 0.487765],
       [1.      , 0.      , 1.      , ..., 0.3791  , 0.780225, 0.30881 ],
       ...,
       [1.      , 0.      , 0.973505, ..., 0.50221 , 0.963485, 0.497115],
       [1.      , 0.      , 0.95304 , ..., 0.481215, 0.937015, 0.418785],
       [1.      , 0.      , 0.92355 , ..., 0.46661 , 0.92882 , 0.469245]])</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sklearn.preprocessing.Normalizer  <span class="comment">#让样本的各特征值之和为 1。</span></span><br><span class="line">sklearn.preprocessing.StandardScaler  <span class="comment">#让特征值均值为 0，方差为 1。这通常是归一化处理的第一步。</span></span><br><span class="line">sklearn.preprocessing.Binarizer  <span class="comment">#把数值特征转换成二值特征，数值在阈值之上取 1，反之则取 0。</span></span><br></pre></td></tr></table></figure>


<h1 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br></pre></td></tr></table></figure>

<p>我们用(‘name’, step)形式的元组表示步骤，并创建流水线。</p>
<p>转换器 -&gt; 估计器 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scaling_pipeline = Pipeline([(<span class="string">'scale'</span>,MinMaxScaler()),</span><br><span class="line">                             (<span class="string">'predict'</span>,KNeighborsClassifier())])</span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores = cross_val_score(scaling_pipeline, X, y, scoring=<span class="string">'accuracy'</span>)</span><br><span class="line">print(accuracy)</span><br></pre></td></tr></table></figure>

<pre><code>86.36363636363636</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://luyilin.top/2020/09/08/C%E5%92%8C%E6%8C%87%E9%92%88/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="luyilin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="引而不发，跃如也">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/08/C%E5%92%8C%E6%8C%87%E9%92%88/C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" class="post-title-link" itemprop="url">C和指针/C语言程序设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-08 09:52:33" itemprop="dateCreated datePublished" datetime="2020-09-08T09:52:33+08:00">2020-09-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-23 09:09:55" itemprop="dateModified" datetime="2020-09-23T09:09:55+08:00">2020-09-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h1><p>打印地址 <code>printf(&quot;address of a : %lp\n&quot;, &amp;a);</code><br>打印变量内存 <code>%lu</code></p>
<p>= 的优先级较低</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">等价于</span><br><span class="line">&#96;&#96;&#96;c</span><br><span class="line">c &#x3D; 25;</span><br><span class="line">b &#x3D; 25;</span><br><span class="line">a &#x3D; 25;</span><br></pre></td></tr></table></figure>

<p>赋值运算符左值与右值类型不相同——转左值<br>尽可能保证类型一致性</p>
<p>函数调用实参与形参的类型不相同——转形参</p>
<p>return 中返回的数与返回类型不相同——转返回类型</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://luyilin.top/2020/08/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="luyilin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="引而不发，跃如也">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">机器学习/异常检测与推荐系统</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-26 20:00:46" itemprop="dateCreated datePublished" datetime="2020-08-26T20:00:46+08:00">2020-08-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-06 16:04:36" itemprop="dateModified" datetime="2020-09-06T16:04:36+08:00">2020-09-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="异常检测"><a href="#异常检测" class="headerlink" title="异常检测"></a>异常检测</h1><h2 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h2><p>$$<br>P(x,\mu,\sigma^2) = \frac{1}{\sqrt{2\pi}\sigma}exp\left(-\frac{(x-\mu)^2}{2\sigma^2}\right)<br>$$</p>
<p>我们认为变量$x$符合高斯分布</p>
<p>其中</p>
<p>$$<br>\quad \mu=\frac{1}{m} \sum_{i=1}^{m} x^{(i)}$$</p>
<p>$$<br>\sigma^{2}=\frac{1}{m} \sum_{i=1}^{m}\left(x^{(i)}-\mu\right)^{2}<br>$$</p>
<p><img src="/2020/08/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/1.JPG" alt="1"></p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><ul>
<li>假设各个特征相互独立</li>
</ul>
<p>对于给定的数据集  $x^{(1)}, x^{(2)}, \ldots, x^{(m)}$,  我们要针对每一个特征计算  $\mu$  和  $\sigma^{2}$  的估计值。<br>$$\mu_{j}=\frac{1}{m} \sum_{i=1}^{m} x_{j}^{(i)}$$<br>$$\sigma_{j}^{2}=\frac{1}{m} \sum_{i=1}^{m}\left(x_{j}^{(i)}-\mu_{j}\right)^{2}$$ </p>
<p>一旦我们获得了平均值和方差的估计值，给定新的一个训练实例，根据 模型计算$p(x)$:<br>$$p(x)=\prod_{j=1}^{n} p\left(x_{j} ; \mu_{j}, \sigma_{j}^{2}\right)=\prod_{j=1}^{n} \frac{1}{\sqrt{2 \pi} \sigma_{j}} \exp \left(-\frac{\left(x_{j}-\mu_{j}\right)^{2}}{2 \sigma_{j}^{2}}\right)$$<br>当$p(x)&lt;\varepsilon$ 时，为异常。 </p>
<h2 id="如何评估"><a href="#如何评估" class="headerlink" title="如何评估"></a>如何评估</h2><p>我们从带标记（异常或正常）的数据着手，从其中选择一部分正常数据用于构建训练集，然后用剩下的正常数据和异常数据混合的数据构成交叉检验集和测试集。</p>
<p>例如：我们有10000台正常引擎的数据，有20台异常引擎的数据。 我们这样分配数据：</p>
<p>6000台正常引擎的数据作为训练集</p>
<p>2000台正常引擎和10台异常引擎的数据作为交叉检验集</p>
<p>2000台正常引擎和10台异常引擎的数据作为测试集</p>
<p>具体的评价方法如下：</p>
<ol>
<li>根据测试集数据，我们估计特征的平均值和方差并构建$P(x)$函数</li>
<li>对交叉检验集，我们尝试使用不同的$\varepsilon$值作为阀值，并预测数据是否异常，根据F1值或者查准率与查全率的比例来选择$\varepsilon$ </li>
<li>选出$\varepsilon$后，针对测试集进行预测，计算异常检验系统的F1值，或者查准率与查全率之比</li>
</ol>
<h2 id="异常检测与监督学习"><a href="#异常检测与监督学习" class="headerlink" title="异常检测与监督学习"></a>异常检测与监督学习</h2><table>
<thead>
<tr>
<th>异常检测</th>
<th>监督学习</th>
</tr>
</thead>
<tbody><tr>
<td>非常少量的正向类（异常数据 ）, 大量的负向类（正常数据）</td>
<td>同时有大量的正向类和负向类</td>
</tr>
<tr>
<td>许多不同种类的异常</td>
<td>有足够多的正向类实例，足够用于训练算法，未来遇到的正向类实例可能与训练集中的非常近似。</td>
</tr>
<tr>
<td>未来遇到的异常可能与已掌握的异常、非常的不同。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="选择特征"><a href="#选择特征" class="headerlink" title="选择特征"></a>选择特征</h2><h3 id="通过变换使特征满足高斯分布"><a href="#通过变换使特征满足高斯分布" class="headerlink" title="通过变换使特征满足高斯分布"></a>通过变换使特征满足高斯分布</h3><p><img src="/2020/08/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E4%B8%8E%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/2.JPG" alt="2"><br>$$x = log(x + c)$$<br>$$x = x^c$$</p>
<h3 id="通过误差分析找到新特征"><a href="#通过误差分析找到新特征" class="headerlink" title="通过误差分析找到新特征"></a>通过误差分析找到新特征</h3><p>从被误判成正常的异常中找到与其他对象所不同的特征</p>
<p>如CPU负载与网络通信量的比例</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://luyilin.top/2020/08/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="luyilin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="引而不发，跃如也">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" class="post-title-link" itemprop="url">机器学习/无监督学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-25 14:20:18" itemprop="dateCreated datePublished" datetime="2020-08-25T14:20:18+08:00">2020-08-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-06 16:05:18" itemprop="dateModified" datetime="2020-09-06T16:05:18+08:00">2020-09-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h1><h2 id="K均值"><a href="#K均值" class="headerlink" title="K均值"></a>K均值</h2><p>迭代算法</p>
<ol>
<li><p>选取K个随机点作为聚类中心，遍历数据集所有点，按照距离K个中心点的距离，将其与距离最近的中心点关联起来，与同一个中心点关联的所有点聚成一类。</p>
</li>
<li><p>计算每一个组的平均值，将该组所关联的中心点移动到平均值的位置。</p>
</li>
<li><p>重复直到中心点不再变化</p>
</li>
</ol>
<h2 id="记号表示"><a href="#记号表示" class="headerlink" title="记号表示"></a>记号表示</h2><p>$c^{(i)}:x^{(i)}$所属的类</p>
<p>$\mu_k:$第k类中心点的位置</p>
<p>$\mu_{c^{(i)}}:x^{(i)}$点所属类的中心点的位置</p>
<h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>$$<br>J\left(c^{(1)}, \ldots, c^{(m)}, \mu_{1}, \ldots, \mu_{K}\right)=\frac{1}{m} \sum_{i=1}^{m}\left|X^{(i)}-\mu_{c^{(i)}}\right|^{2}<br>$$</p>
<p>回顾刚才给出的: K-均值迭代算法，我们知道，第一个循环是用于减小$c^{(i)}$引起的代价，而第二个循环则是用于减小$\mu_i$引起的代价。迭代的过程一定会是每一次迭代都在减小代价函数，不然便是出现了错误。</p>
<h2 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h2><ol>
<li>$K&lt;m$</li>
<li>随机选择K个训练实例，然后令K个聚类中心分别与这K个训练实例相等</li>
</ol>
<p>多次运行K-均值算法，每一次都重新进行随机初始化，最后再比较多次运行K-均值的结果，选择代价函数最小的结果。这种方法在K较小的时候（2–10）还是可行的，但是如果K较大，这么做也可能不会有明显地改善。</p>
<h2 id="选择聚类数"><a href="#选择聚类数" class="headerlink" title="选择聚类数"></a>选择聚类数</h2><ol>
<li>肘部法则<br><img src="/2020/08/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/1.JPG" alt="1"></li>
<li>按实际需求选择</li>
</ol>
<h1 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li>数据压缩<ul>
<li>加速监督算法</li>
</ul>
</li>
<li>可视化 </li>
</ul>
<h2 id="主成分分析（PCA）"><a href="#主成分分析（PCA）" class="headerlink" title="主成分分析（PCA）"></a>主成分分析（PCA）</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>找到一个方向向量（Vector direction），当我们把所有的数据都投射到该向量上时，我们希望投射平均均方误差能尽可能地小。方向向量是一个经过原点的向量，而投射误差是从特征向量向该方向向量作垂线的长度。</p>
<p>主成分分析与线性回归是两种不同的算法。主成分分析最小化的是投射误差（Projected Error），而线性回归尝试的是最小化预测误差。线性回归的目的是预测结果，而主成分分析不作任何预测。</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>将n维减少的k维</p>
<ol>
<li>均值归一化：如果特征是在不同的数量级上，我们还需要将其除以标准差$\sigma^2$。</li>
<li>第二步是计算协方差矩阵（covariance matrix）<br>$$\Sigma=\frac{1}{m} \sum_{i=1}^{n}\left(x^{(i)}\right)\left(x^{(i)}\right)^{T}$$</li>
<li>奇异值分解<br><code>[U,S,V] = svd(sigma)</code><br>对于一个  $n \times n$  维度的矩阵, 上式中的U是一个具有与数据之间最小投射误差的方向向量构成的矩阵。如果我们希望将数据从$n$维降至  $k$  维，我们只需要从U中选取前k个向量，获得一个$n\times k$维度的矩阵，我们用  $U_{\text {reduce}}$  表示，然后通过如下计算获得要求的新特征向量  $z^{(i)}$  :<br>$$z^{(i)}=U_{r e d u c e}^{T} * x^{(i)}$$<br>其中  $x$  是  $n \times 1$  维的，因此结果为  $k \times 1$  维度。</li>
</ol>
<h2 id="主成分数量"><a href="#主成分数量" class="headerlink" title="主成分数量"></a>主成分数量</h2><p>我们获得三个参数：<code>[U, S, V] = svd(sigma)</code>。<br>其中的S是一个$n\times n$的矩阵，只有对角线上有值，而其它单元都是0</p>
<p>我们可以使用这个矩阵来计算平均均方误差与训练集方差的比例 :<br>$$<br>\frac{\frac{1}{m} \sum_{i=1}^{m}\left|x^{(i)}-x_{a p p r o x}^{(i)}\right|^{2}}{\frac{1}{m} \sum_{i=1}^{m}\left|x^{(i)}\right|^{2}}=1-\frac{\Sigma_{i=1}^{k} S_{i i}}{\Sigma_{i=1}^{m} S_{i i}} \leq 1 %<br>$$<br>也就是：<br>$$\quad \frac{\Sigma_{i=1}^{k} s_{i i}}{\Sigma_{i=1}^{n} s_{i i}} \geq 0.99$$<br>在压缩过数据后，我们可以采用如下方法来近似地获得原有的特征:<br> $$x_{a p p r o x}^{(i)}=U_{r e d u c e} z^{(i)}$$ </p>
<h2 id="压缩的还原"><a href="#压缩的还原" class="headerlink" title="压缩的还原"></a>压缩的还原</h2><p>$$z=U_{\text {reduce}}^{T} x$$<br>相反的方程为：<br>$$x_{a p p o x}=U_{r e d u c e} \cdot z_{1}$$<br>$$x_{a p p o x} \approx x $$</p>
<h2 id="应用建议"><a href="#应用建议" class="headerlink" title="应用建议"></a>应用建议</h2><ol>
<li>PCA不能防止过拟合</li>
<li>在学习时可以先不用PCA降维操作一遍看看是否能得到好的结构，如果不能再考虑PCA</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://luyilin.top/2020/08/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA(Support%20Vector%20Machines)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="luyilin">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="引而不发，跃如也">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA(Support%20Vector%20Machines)/" class="post-title-link" itemprop="url">机器学习/支持向量机(Support Vector Machines)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-24 09:06:01 / Modified: 21:18:49" itemprop="dateCreated datePublished" datetime="2020-08-24T09:06:01+08:00">2020-08-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在学习复杂的非线性方程时提供了一种更为清晰，更加强大的方式。</p>
<h1 id="构建支持向量机"><a href="#构建支持向量机" class="headerlink" title="构建支持向量机"></a>构建支持向量机</h1><p><img src="/2020/08/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA(Support%20Vector%20Machines)/1.JPG" alt="1"></p>
<ul>
<li>修改了逻辑回归中的代价函数</li>
</ul>
<p>$$J(\theta)=\frac{1}{m} \sum_{i=1}^{m}\left[y^{(i)} (-\log \left(h_{\theta}\left(x^{(i)}\right)\right))+\left(1-y^{(i)}\right) (-\log \left(1-h_{\theta}\left(x^{(i)}\right)\right))\right]+ \frac{\lambda}{2m}\sum_{j = 1}^n\theta_j^2$$</p>
<p>修改代价函数<br>$$J(\theta)=\sum_{i=1}^{m}\left[y^{(i)} cost_1(\theta^Tx^{(i)})+\left(1-y^{(i)}\right) cost_0(\theta^Tx^{(i)})\right]+ \frac{\lambda}{2}\sum_{j = 1}^n\theta_j^2$$</p>
<p>$$min(A + \lambda B)\rightarrow min(CA + B), C = \frac{1}{\lambda}$$</p>
<p>$$J(\theta)=C\sum_{i=1}^{m}\left[y^{(i)} cost_1(\theta^Tx^{(i)})+\left(1-y^{(i)}\right) cost_0(\theta^Tx^{(i)})\right]+ \frac{1}{2}\sum_{j = 1}^n\theta_j^2$$</p>
<h1 id="大边界"><a href="#大边界" class="headerlink" title="大边界"></a>大边界</h1><p>希望$\theta^Tx&gt;=1$</p>
<p>大间距分类器，C越大对异常点越敏感</p>
<p>$C = \frac{1}{\lambda}$，因此：</p>
<p>$C$较大时，相当于$\lambda$较小，可能会导致过拟合，高方差。</p>
<p>$C$较小时，相当于$\lambda$较大，可能会导致低拟合，高偏差。</p>
<h1 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h1><p><img src="/2020/08/24/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA(Support%20Vector%20Machines)/2.JPG" alt="2"></p>
<p>高斯核函数</p>
<p>$$f_i = exp(-\frac{||x - l^{(i)}||^2}{2\sigma^2})$$</p>
<p>$$<br>h_{\theta}(x)=\theta_{0}+\theta_{1} f_{1}+\theta_{2} f_{2}+\theta_{1} f_{3}&gt;0, \text { 则预测 } y=1 .<br>$$</p>
<p>$\sigma$较大时，可能会导致低方差, 高偏差;</p>
<p>$\sigma$较小时，可能会导致低偏差, 高方差。</p>
<ul>
<li>如何选择特征点？将训练集作为特征点带入即可</li>
</ul>
<h1 id="算法选择"><a href="#算法选择" class="headerlink" title="算法选择"></a>算法选择</h1><p>$n &gt; m$ 逻辑回归</p>
<p>$n &lt; m$   </p>
<ul>
<li>m较小，例如$n$在1-1000 之间，而$m$在10-10000之间，SVM高斯核函数</li>
<li>m较大，例如$n$在1-1000之间，而$m$大于50000,SVM线性核函数/逻辑回归</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">luyilin</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">53</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        </script>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luyilin</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
